True|44396500|44396824|1|0|However one really neat feature of this auto-generated conformance is that if you define a nested CW in your type called `` CW '' ( or use a CW with this name ) that conforms to the LINK protocol -- Swift will automatically use this as the key type . |you define CW in type called `` CW '' -LRB- or use CW with name -RRB- that conforms to protocol |['protocol', 'name', 'type']|[]|['protocol', 'name', 'type']|False|False|False|False
True|44396500|44396824|11|0|In Swift 4.1 , if you rename your CW property to CW , you can take advantage of the key encoding/decoding strategies on CW and CW in order to automatically convert coding keys between CW and CW . |you rename property to CW |['property']|[]|['property']|False|False|False|False
True|29599005|43198481|4|0|Note : if you want CW as a string , it is very simply to convert to a string : CW |you want CW as string |['string']|[]|['string']|False|False|False|False
True|28547288|38000615|2|0|You can use it for debugging your app on a local machine ( if everything works in production ) . |everything works in production -RRB- |['production']|[]|['production', 'everything']|False|False|False|False
True|44603248|44621628|1|0|Oftentimes , if you reach deep enough into the API 's documentation , you will find the full list of all potential metadata keys . |you reach enough into 's documentation |['documentation']|['documentation']|['documentation']|False|False|False|False
True|39423367|39423764|20|0|If you need an item at specific index check also if the index exists |you need item at check also index exists |['index', 'item', 'check']|[]|['index', 'item', 'check']|False|False|False|False
False|33660866|40901513|6|0|However , if I use the CW to search this table very frequently , what should I do ? |I use CW to search table frequently |['table']|[]|['table']|True|True|False|False
True|33660866|49576873|7|1|Virtual generated columns perform much faster , however , if we know our data structure beforehand , we do n't need JSON , we can use traditional columns instead . |we know structure beforehand |['structure']|[]|['structure']|False|False|False|False
True|33660866|51954906|5|0|Or even if you query the exact expression that the virtual column is based on ( as in your original query ) , then it can also use the index . |you query expression that column is based on -LRB- as in query -RRB- |['query', 'expression']|[]|['column', 'query', 'expression']|False|False|False|False
False|28459418|29568747|13|0|Now , I do n't know if I particularly agree with the article as many commentators point out . |I particularly agree with article as commentators point out |['commentators', 'article']|[]|['commentators', 'article']|False|True|False|False
True|28459418|34400076|11|0|Since PUT requests include the entire entity , if you issue the same request repeatedly , it should always have the same outcome ( the data you sent is now the entire data of the entity ) . |you issue request repeatedly |['request']|[]|['request']|False|False|False|False
False|28459418|34400076|12|0|What happens if you use the above PATCH data in a PUT request ? |you use data in request |['request']|[]|['request', 'data']|True|False|False|False
False|28459418|39338329|8|0|Now , if we issue the exact same PATCH request as above , what happens ? |we issue request above |['request']|[]|['request']|True|False|False|False
True|28459418|44032880|6|1|But if you define operations like : `` increment '' or `` append '' , you can easily see it wo n't be idempotent anymore . |you define operations like : '' or '' |['operations']|[]|['operations']|False|False|False|False
True|28459418|53319895|3|0|Idempotent methods are distinguished because the request can be repeated automatically if a communication failure occurs before the client is able to read the server 's response . |failure occurs before client is able to read 's response |['response', 'client']|['failure']|['response', 'failure', 'client']|False|False|False|False
True|28459418|53319895|3|1|For example , if a client sends a PUT request and the underlying connection is closed before any response is received , then the client can establish a new connection and retry the idempotent request . |client sends request and connection is closed before response is received |['request', 'connection', 'response', 'client']|[]|['request', 'connection', 'response', 'client']|False|False|False|False
True|28459418|53319895|7|0|If instead the client uses a PUT request to correct the email , sending to the server all properties of user 1 along with the email , his intended effect will be achieved even if the request has to be re-sent later and user 1 has been modified in the meanwhile -- since the second PUT request will overwrite all changes since the first request . |instead client uses request to correct email |['request', 'email', 'client']|[]|['request', 'email', 'client']|False|False|False|False
True|31469441|31509502|0|3|I 'm not sure if this applies to some Java frameworks , too . |this applies to frameworks |['frameworks']|[]|['frameworks']|False|False|False|False
True|29775797|45345813|1|0|However , if you try with jQuery 's CW and it 's working , the reason is probably because of jQuery using CW instead of CW . |you try with 's CW and it 's working |['jquery']|[]|['jQuery']|False|False|False|False
True|29775797|49517293|0|0|I think that , we do n't need parse the JSON object into a string , if the remote server accepts json into they request , just run : |server accepts json into they request |['json', 'json', 'server']|[]|['JSON', 'json', 'server']|False|False|False|False
True|32960857|32967407|5|2|This will also prevent values being in the wrong columns if some objects have a different key order . |objects have order |['objects', 'order']|[]|['objects', 'order']|False|False|False|False
True|31096130|31096160|2|0|So if the CW format is what you want , then simply stringify that : |format is what you |['format']|[]|['format']|False|False|False|False
True|36856232|36856787|8|4|With this , you can check if the file exists . |file exists |['file']|[]|['file']|False|False|False|False
True|30481979|32956160|0|0|Based on the LINK , the easiest way is to use a CW request which according to the docs either `` adds a new list member or updates the member if the email already exists on the list '' . |email already exists on list |['list', 'email']|[]|['list', 'email']|False|False|False|False
True|36001695|49575969|0|0|Not sure if anyone still runs into this issue but I was able to address this in a dotnetcore console project ( netcoreapp2 .0 ) via : |anyone still runs into issue but I was able to address this in project -LRB- .0 -RRB- via : |['project']|[]|['issue', 'anyone', 'project']|False|False|False|False
True|31537153|34516075|0|0|This can happen if you have a newline ( or other control character ) in a JSON string literal . |you have newline -LRB- or other character -RRB- in string literal |['string', 'newline', 'character']|[]|['string', 'newline', 'character']|False|False|False|False
True|31537153|43995658|0|0|I 'd recommend you to use a text editor such as Vim to find if there are any ( invisible ) special or escape characters causing this issue . |there are any -LRB- invisible -RRB- special or characters causing issue |['characters']|[]|['issue', 'characters']|False|False|False|False
True|30568353|46601536|1|0|EDIT : And use a protected/package-protected default constructor for parent classes if you have inheritance . |you have inheritance |['inheritance']|[]|['inheritance']|False|False|False|False
True|28646332|28647129|2|1|For example , if the request says it accepts XML , but not JSON , and there is a message converter installed that can transform the list to XML , then XML will be returned . |request says it accepts XML |['request']|[]|['request']|False|False|False|False
True|40574159|40574235|3|1|This only works if the URL provides JSONP ( which is a different subset of JavaScript ) , which this one does n't . |URL provides JSONP -LRB- which is subset of JavaScript -RRB- |['javascript', 'subset']|[]|['JavaScript', 'subset']|False|False|False|False
False|43494824|43612427|0|0|The `` golden rule '' I use , in a hand-wavey sort of way , is that if I need JSON in its raw format , it 's okay to store . |I need JSON in format |['format']|[]|['format']|False|True|False|False
True|31930041|31935351|4|0|POSTSCRIPT : walk/1 is a built-in in versions of jq > 1.5 , and can therefore be omitted if your jq includes it , but there is no harm in including it redundantly in a jq script . |jq includes it |['jq']|[]|['jq']|False|False|False|False
True|31930041|37175540|0|0|In principle , if you have access to bash or some other advanced shell , you could do something like |you have access to bash or shell |['access', 'shell']|[]|['access', 'shell']|False|False|False|False
True|31930041|37175540|2|6|Alternatively if you want them to be represented as a set , and the elements are strings , you could put them in objects like CW . |you want them to be represented as set |['set']|[]|['set']|False|False|False|False
True|34287402|52277406|0|2|For example , if the user does not have access to the data URL and gets some HTML instead . |user not have access to URL and gets HTML instead . |['access']|['user']|['access', 'user']|False|False|False|False
True|44655562|50053529|1|0|Some CW structs will be able to parse your CW file just fine if you restructure it using recursive hashes , i.e. if your CW just contains an array of CW which in turn contains ( one or several ) CW . |you restructure it using hashes |['hashes']|[]|['hashes']|False|False|False|False
True|31905260|35424786|0|0|This may not qualify for the complete answer , but if the purpose is to send a message attachment , you can send a CWd JSON structure as the value of the CW parameter , like so ( split into multiple lines for clarity ) : |purpose is to send attachment |['attachment']|[]|['purpose', 'attachment']|False|False|False|False
True|35844138|35845278|1|0|There is a already an LINK for this in the postgres driver Github repository ( even if the problem seems the be the serverside processing ) . |problem seems the be processing -RRB- |['processing']|[]|['processing', 'problem']|False|False|False|False
True|41336663|41336869|2|0|Note that if you use Chrome 's console you should be able to browse through the object without having to stringify the JSON , which makes it easier to debug . |you use 's console you should be able to browse through object without having to stringify JSON |['console', 'object']|[]|['console', 'object']|False|False|False|False
True|39024354|46159307|3|1|If you have a highly developed modeling , you will more then likely have a set where you think you going to get your intended entity and it 's child list , but if those list items also have children , or other parents then you will load those . |you have a developed modeling |['modeling']|[]|['modeling']|False|False|False|False
True|33088462|33094930|0|0|Well , if you just need a single extra property , one simple approach is to parse your JSON to a CW , use CW to populate your class from the CW , and then use CW to pull in the extra property . |you just need property |['property']|[]|['property']|False|False|False|False
True|49645813|49646254|3|0|and if you want it as an array of pairs : |you want it as array of pairs : |['pairs', 'array']|[]|['pairs', 'array']|False|False|False|False
True|34226370|34227629|1|0|CW produces the key names in sorted order ; if you want them in the original order , use CW . |you want them in order |['order']|[]|['order']|False|False|False|False
True|30777419|30778141|0|0|With Retrofit 1.9.0 , if you use the Callback asynchronous version of the interface , |you use version of interface |['version', 'interface']|['interface']|['version', 'interface', '1.9.0']|False|False|False|False
True|29571284|29574160|3|2|So , if a client has a broken implementation , it can write the CW request as a CW , sending the CW method , and you can have a middleware that 's decoupled from your application implementation and rewrites the method accordingly . |client has implementation |['implementation', 'client']|[]|['implementation', 'client']|False|False|False|False
True|49996456|51494250|4|0|But if you have an CW property in your CW : |you have property in CW : |['property']|[]|['property']|False|False|False|False
True|47266862|52106099|3|0|Be careful with nested structs : E.g. if you have a property with a custom struct as type , you need to convert that to a dictionary too . |you have property with struct as type |['struct', 'property', 'type']|[]|['struct', 'property', 'type']|False|False|False|False
True|35123835|35183644|2|0|Another benefit of this approach would be if a client wants XML instead of JSON , they would get it . |client wants XML of JSON |['client']|[]|['client']|False|False|False|False
True|34516332|34516875|1|0|However this will not result in any errors if the server sends you bad objects because of 2 reasons . |server sends you objects |['objects', 'server']|[]|['objects', 'server']|False|False|False|False
True|29247235|29840307|1|2|Later , if no items get merged into it , you simply CW it before CW gets added to the main object . |items get merged into it |['items']|[]|['items']|False|False|False|False
True|32942661|32943372|2|1|Members of Items.java can be changed if JSON has other keys . |JSON has keys |['keys']|[]|['keys', 'Items.java']|False|False|False|False
True|51704138|51751913|11|0|As of these releases , if you try and pass a string with an unmatched surrogate pair , Node will replace that character with the unknown unicode character ( U+FFFD ) . |you try and pass string with pair |['string', 'pair']|[]|['string', 'pair']|False|False|False|False
True|51704138|51781777|7|1|And you might also want to install CW to efficiently check if a message contains valid UTF-8 as required by the spec . |message contains as required by spec |['message', 'spec']|[]|['message', 'spec']|False|False|False|False
True|32818884|34838334|0|0|I have found if you create the visual studio solution folder on a UNC path this error will occur . |you create folder on path |['folder', 'path']|[]|['folder', 'path']|False|False|False|False
True|38806490|40377740|1|0|So , if you create/upload your own file in Google Storage -- like I 'm doing now while trying to test the same API you are using -- the `` equivalence '' is the following : |you create/upload file in Storage -- like I 'm doing now while trying to test API you are using -- equivalence '' is following : |['file']|[]|['file', 'following']|False|False|False|False
True|42395200|42395516|2|0|You could also try generating a new project with the cli with CW and see if it contains the CW file . |it contains file |['file']|[]|['file']|False|False|False|False
True|35709595|38357877|1|3|It is this variability that can be a pain if your application has specific precision requirements . |application has requirements |['requirements', 'application']|[]|['requirements', 'application']|False|False|False|False
True|35709595|38357877|5|0|So if you are wanting to send a precise numeric value to a consumer and you do n't want automatic conversion of the value into the typical internal numeric representation , your best bet is to ship the numeric value out as a string and tell the consumer exactly how that string should be processed if and when numeric operations need to be performed on it . |you are wanting to send value to consumer and you n't want conversion of value into representation |['value', 'consumer', 'representation']|[]|['value', 'conversion', 'consumer', 'representation']|False|False|False|False
True|35709595|38357877|9|3|Simpler for the client to display stuff on screen perhaps , but this can make extracting the numeric value from the string difficult if the client also needs to make computations on the values . |client also needs to make computations on values |['values', 'computations', 'client']|[]|['values', 'computations', 'client']|False|False|False|False
True|31102784|31234613|1|1|It 's best if you separate those two steps . |you separate steps |['steps']|[]|['steps']|False|False|False|False
True|38615482|38749477|2|0|and see if you get a valid response stream . |you get stream |['stream']|[]|['stream']|False|False|False|False
True|35481817|35482323|8|1|This must start with CW ( see above ) , so if you wrap it with a bracket ( CW ) it can not be a CW ... But if it matches as CW it must be a CW . |you wrap it with bracket -LRB- CW -RRB- it not be CW ... But it matches as CW it must be CW |['bracket']|[]|['bracket']|False|False|False|False
True|35481817|35482504|3|0|The same applies if you put this into an CW statement . |you put this into statement |['statement']|[]|['statement']|False|False|False|False
False|29044209|29186757|0|0|Does this code pattern create a XSS vulnerability , if an attacker chooses url maliciously ? |attacker chooses url maliciously |['url']|[]|['url', 'attacker']|True|False|False|False
False|34660641|34685114|4|1|Please correct me if I 'm wrong or if this needs more detail . |I 'm wrong or this needs detail |['detail']|[]|['detail']|False|True|False|False
False|30249406|30266100|7|0|However , it does leave a problem -- what if the app needs to perform calculations and then show the results to the user ? |app needs to perform calculations and then show results to user ? |['results', 'calculations']|['user']|['results', 'user', 'app', 'calculations']|True|False|False|False
True|30249406|53679769|2|0|However it would only be meaningful if any part of the system avoids floating point too . |part of system avoids point too |['system', 'point', 'part']|[]|['system', 'point', 'part']|False|False|False|False
True|33207376|42820141|0|2|What I do is specifically ask if the object responds to a particular method . |object responds to method |['object', 'method']|[]|['object', 'method']|False|False|False|False
True|36354704|50148332|1|0|If you do not use optional values , you have to control parameters while parsing and add a default value if you want a crash free app . |you not use values |['values']|[]|['values']|False|False|False|False
True|38380462|43192024|5|0|Beware : Also , on client side , if you make ajax request and use JSON.parse ( `` OK '' ) , it throws Unexpected token ` O ' |you make request and JSON.parse -LRB- '' -RRB- |['request']|[]|['request', 'JSON.parse']|False|False|False|False
True|40421100|40423914|9|0|Then you 'll get the error because it 's not a string , it 's an object , and if you already have it in this form then there 's no need to use CW . |you already have it in form then there 's need to use CW |['form']|[]|['form', 'need']|False|False|False|False
True|35760096|35760153|1|1|One quick workaround ( if you have the luxury of code generation you can automate this ) : |you have luxury of generation you can automate this -RRB- |['generation']|[]|['luxury', 'generation']|False|False|False|False
True|45430535|46525856|6|1|( I did not choose this option because the ` lambda ' limits are lower than the Firehose limits , you can configure Firehose to write a file each 128Mb or 15 minutes , but if you associate this lambda function to Firehose , the lambda function will be executed every 3 mins or 5 MB , in my case I had the problem of generate a lot of little parquet files , as for each time that the lambda function is launched I generate at least 10 files ) . |you associate function to Firehose |['function']|[]|['function', '128Mb']|False|False|False|False
True|48535819|48597168|5|2|I believe if the purpose of creating the json file is to import it in some form , at some stage in future , I think you might have to look at the option of just having a csv file instead , which you use to filter out whatever is required at that point of time . |purpose of creating file is to import it in form |['file', 'form']|[]|['purpose', 'file', 'form']|False|False|False|False
True|48535819|48597168|9|0|Even if you get past this point , you will still run into memory issues , due to the way how you are storing everything in $ json variable which is eating up lot of your memory . |you get past point |['point']|[]|['point']|False|False|False|False
True|30156407|30355169|2|0|However , if your server delivers public api services then you should validate the calls upfront . |server delivers services then you should validate upfront . |['services', 'server']|[]|['services', 'upfront', 'server']|False|False|False|False
True|34325096|34377323|1|1|So if you hardcode this name you should remember to insert them or you will get error . |you hardcode name you should remember to insert them |['name']|[]|['name']|False|False|False|False
True|36745691|36763214|1|0|However , if you just have a local repo without releases , you have to use : |you just have repo without releases |['releases', 'repo']|[]|['releases', 'repo']|False|False|False|False
True|33122014|33174045|0|1|As others have already pointed out , there is not much you can do to avoid conflicts if you have that high number of changes happening to the config all the time . |you have number of changes happening to config time |['time', 'number', 'config']|['time']|['time', 'number', 'config', 'changes']|False|False|False|False
True|31473215|49726900|1|0|Let me know if you have a sample Dataframe and a format of JSON to convert . |you have sample Dataframe and format of JSON to convert |['sample', 'format']|[]|['sample', 'format']|False|False|False|False
False|39065676|39942490|0|3|If just return string CW represent CW what if i want to return string CW instead of CW . |just CW represent CW what i want to return CW of CW |['return']|[]|['return']|False|True|False|False
False|29026596|36774144|0|0|Might be a little bit off-topic , but what happens if the inner object contains a Date property ? |object contains property |['object', 'property']|[]|['object', 'property']|True|False|False|False
True|29164419|36127195|3|1|The CW function by default removes all fields those are CW or you have to explicitly pass the field names if that 's not desired and you have to pass CW argument too if CW takes the same . |that not desired and you have to pass argument too CW takes same |['argument']|[]|['argument']|False|False|False|False
True|35444968|35544154|2|3|Hence , if there are 4 addresses and 8 plans , there will be 4 * 8 = 32 rows in the joined data frame . |there are addresses and plans |['addresses', 'plans']|[]|['addresses', 'plans']|False|False|False|False
True|35444968|35574705|1|0|If you want to keep the semantics of the fields , like keep all CWs in a single column , you can normalize your data design a bit , and do joins afterwards , if you need the information together : |you want to keep semantics of fields |['fields', 'semantics']|[]|['fields', 'semantics']|False|False|False|False
True|33423853|33579524|4|0|or if you want this without jQuery , which is same as what @daniel - flint recommended . |you want this without jQuery |['jquery']|[]|['@daniel', 'jQuery']|False|False|False|False
True|37816269|52402431|1|0|The first one , CW picks only the first value if there are multiple keys with the same name . |there are keys with name |['keys', 'name']|[]|['keys', 'name']|False|False|False|False
True|37816269|52402431|4|1|You can speed up if you prepare a table for the CW subselect . |you prepare table for subselect |['table']|[]|['subselect', 'table']|False|False|False|False
True|37816269|52402431|5|0|Yep , and if you have the chance , try to upgrade to MySQL 5.7 , the built-in functions work much more efficiently . |you have chance |['mysql']|[]|['chance', 'MySQL']|False|False|False|False
True|41117918|41148344|2|3|So , if you put JSON into scratch buffer it wo n't get formatted with JSON type formatter . |you put JSON into buffer it n't get formatted with formatter . |['buffer', 'formatter']|['buffer']|['buffer', 'formatter']|False|False|False|False
True|41117918|41148344|3|0|I would encourage you to use scratch files instead of scratch buffers if you want JSON formatting . |you want formatting |['formatting']|[]|['formatting']|False|False|False|False
True|45532477|45963989|1|2|( Also there is a lot that can go wrong if you do operations like this with regex ... ) |you do operations like this with regex ... |['operations', 'regex']|[]|['operations', 'regex']|False|False|False|False
True|30692185|30854521|1|2|You could also be bitten by the provider if they reject requests with parameters they do n't expect . |they reject requests with parameters they n't expect |['parameters', 'requests']|[]|['parameters', 'requests']|False|False|False|False
