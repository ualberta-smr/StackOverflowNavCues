QuestionId|AnswerID|ParagraphIndex|SentenceIndex|Sentence|TruePositive?|Condition|Tags In Condition|NFReqs|Nouns|IsFirstPerson?|IsUnsurePhrase?|HasWantedGrammerDep?
44396500|44396824|1|0|However one really neat feature of this auto-generated conformance is that if you define a nested CW in your type called `` CW'' ( or use a CW with this name ) that conforms to the LINK protocol -- Swift will automatically use this as the key type.|True|you define CW in type called `` CW '' -LRB- or use CW with name -RRB- that conforms to protocol |['type', 'name', 'protocol']|[]|['type', 'name', 'protocol']|False|False|False|False
44396500|44396824|11|0|In Swift 4.1, if you rename your CW property to CW, you can take advantage of the key encoding/decoding strategies on CW and CW in order to automatically convert coding keys between CW and CW.|False|you rename property to CW |['property']|[]|['property']|False|False|False|False
29599005|43198481|4|0|Note: if you want CW as a string, it is very simply to convert to a string: CW|True|you want CW as string |['string']|[]|['string']|False|False|False|False
28547288|38000615|2|0|You can use it for debugging your app on a local machine ( if everything works in production ).|False|everything works in production -RRB- |['production']|[]|['production', 'everything']|False|False|False|False
44603248|44621628|1|0|Oftentimes, if you reach deep enough into the API's documentation, you will find the full list of all potential metadata keys.|False|you reach enough into 's documentation |['documentation']|['documentation']|['documentation']|False|False|False|False
39423367|39423764|9|0|The only ( rare ) option which is useful in Swift is CW which is required if if the JSON root object could be a value type ( CW, CW, CW or CW ) rather than one of the collection types ( CW or CW ).|True|object could be type |['type', 'object']|[]|['type', 'object']|False|False|False|False
39423367|39423764|20|0|If you need an item at specific index check also if the index exists|True|you need item at check also index exists |['check', 'index', 'item']|[]|['check', 'index', 'item']|False|False|False|False
33660866|40901513|6|0|However, if I use the CW to search this table very frequently, what should I do ?|False|I use CW to search table frequently |['table']|[]|['table']|True|True|False|False
33660866|49576873|7|1|Virtual generated columns perform much faster, however, if we know our data structure beforehand, we do n't need JSON, we can use traditional columns instead.|True|we know structure beforehand |['structure']|[]|['structure']|False|False|False|False
33660866|51954906|5|0|Or even if you query the exact expression that the virtual column is based on ( as in your original query ), then it can also use the index.|True|you query expression that column is based on -LRB- as in query -RRB- |['expression', 'query']|[]|['expression', 'query', 'column']|False|False|False|False
28459418|29568747|13|0|Now, I do n't know if I particularly agree with the article as many commentators point out.|False|I particularly agree with article as commentators point out |['commentators', 'article']|[]|['commentators', 'article']|False|True|False|False
28459418|34400076|11|0|Since PUT requests include the entire entity, if you issue the same request repeatedly, it should always have the same outcome ( the data you sent is now the entire data of the entity ).|True|you issue request repeatedly |['request']|[]|['request']|False|False|False|False
28459418|34400076|12|0|What happens if you use the above PATCH data in a PUT request ?|False|you use data in request |['request']|[]|['request', 'data']|True|False|False|False
28459418|39338329|8|0|Now, if we issue the exact same PATCH request as above, what happens ?|False|we issue request above |['request']|[]|['request']|True|False|False|False
28459418|44032880|6|1|But if you define operations like: `` increment'' or `` append'', you can easily see it wo n't be idempotent anymore.|True|you define operations like : '' or '' |['operations']|[]|['operations']|False|False|False|False
28459418|53319895|3|0|Idempotent methods are distinguished because the request can be repeated automatically if a communication failure occurs before the client is able to read the server's response.|True|failure occurs before client is able to read 's response |['client', 'response']|['failure']|['client', 'failure', 'response']|False|False|False|False
28459418|53319895|3|1|For example, if a client sends a PUT request and the underlying connection is closed before any response is received, then the client can establish a new connection and retry the idempotent request.|True|client sends request and connection is closed before response is received |['client', 'connection', 'request', 'response']|[]|['client', 'connection', 'request', 'response']|False|False|False|False
28459418|53319895|7|0|If instead the client uses a PUT request to correct the email, sending to the server all properties of user 1 along with the email, his intended effect will be achieved even if the request has to be re-sent later and user 1 has been modified in the meanwhile -- since the second PUT request will overwrite all changes since the first request.|True|instead client uses request to correct email |['client', 'email', 'request']|[]|['client', 'email', 'request']|False|False|False|False
31469441|31509502|0|3|I'm not sure if this applies to some Java frameworks, too.|False|this applies to frameworks |['frameworks']|[]|['frameworks']|False|False|True|False
29775797|45345813|1|0|However, if you try with jQuery's CW and it's working, the reason is probably because of jQuery using CW instead of CW.|True|you try with 's CW and it 's working |['jquery']|[]|['jQuery']|False|False|False|False
29775797|49517293|0|0|I think that, we do n't need parse the JSON object into a string, if the remote server accepts json into they request, just run:|True|server accepts json into they request |['server', 'json', 'json']|[]|['server', 'JSON', 'json']|False|False|False|False
33650399|42032709|0|0|json-loader does n't load json file if it's array, in this case you need to make sure it has a key, for example|True|it 's array |['array']|[]|['array']|False|False|False|False
32960857|32967407|5|2|This will also prevent values being in the wrong columns if some objects have a different key order.|True|objects have order |['order', 'objects']|[]|['order', 'objects']|False|False|False|False
31096130|31096160|2|0|So if the CW format is what you want, then simply stringify that:|True|format is what you |['format']|[]|['format']|False|False|False|False
36856232|36856787|8|4|With this, you can check if the file exists.|True|file exists |['file']|[]|['file']|False|False|False|False
30481979|32956160|0|0|Based on the LINK, the easiest way is to use a CW request which according to the docs either `` adds a new list member or updates the member if the email already exists on the list''.|True|email already exists on list |['list', 'email']|[]|['list', 'email']|False|False|False|False
30480672|30480777|4|2|Last note: this works only if your value is a String.|True|value is String |['value']|[]|['value']|False|False|False|False
36001695|49575969|0|0|Not sure if anyone still runs into this issue but I was able to address this in a dotnetcore console project ( netcoreapp2 .0 ) via:|False|anyone still runs into issue but I was able to address this in project -LRB- .0 -RRB- via : |['project']|[]|['issue', 'anyone', 'project']|False|False|True|False
31537153|34516075|0|0|This can happen if you have a newline ( or other control character ) in a JSON string literal.|True|you have newline -LRB- or other character -RRB- in string literal |['character', 'string', 'newline']|[]|['character', 'string', 'newline']|False|False|False|False
31537153|43995658|0|0|I'd recommend you to use a text editor such as Vim to find if there are any ( invisible ) special or escape characters causing this issue.|True|there are any -LRB- invisible -RRB- special or characters causing issue |['characters']|[]|['issue', 'characters']|False|False|False|False
30568353|46601536|1|0|EDIT: And use a protected/package-protected default constructor for parent classes if you have inheritance.|True|you have inheritance |['inheritance']|[]|['inheritance']|False|False|False|False
28646332|28647129|2|1|For example, if the request says it accepts XML, but not JSON, and there is a message converter installed that can transform the list to XML, then XML will be returned.|True|request says it accepts XML |['request']|[]|['request']|False|False|False|False
43494824|43495014|4|0|It is perfectly okay to store a complete structure as one bit of information if it is one bit of information actually.|False|it is bit of information actually |['bit']|[]|['bit', 'information']|False|False|False|False
43494824|43612427|0|0|The `` golden rule'' I use, in a hand-wavey sort of way, is that if I need JSON in its raw format, it's okay to store.|False|I need JSON in format |['format']|[]|['format']|False|True|False|False
40574159|40574235|3|1|This only works if the URL provides JSONP ( which is a different subset of JavaScript ), which this one does n't.|False|URL provides JSONP -LRB- which is subset of JavaScript -RRB- |['subset', 'javascript']|[]|['subset', 'JavaScript']|False|False|False|False
29696572|29696688|0|0|you can use push method only if the object is an array:|True|object is array |['array', 'object']|[]|['array', 'object']|False|False|False|False
29696572|41064401|0|0|make sure you push into an Array only and if their is error like Uncaught TypeError: data.push is not a function ** then check for type of data you can do this by consol.log ( data ) hope this will help|True|their is error like TypeError : data.push not function ** then check for type of data you can do this by consol.log -LRB- data -RRB- hope this will help |['function', 'type']|['error']|['data', 'function', 'data.push', 'consol.log', 'type', 'error']|False|False|False|False
31276220|32931094|3|0|You can fix this problem if you are the owner of both domains:|False|you are owner of domains |['owner']|[]|['domains', 'owner']|False|False|False|False
28596295|48112890|1|0|From this if a user need message then he can get alert message.|True|message then |['message']|[]|['message']|False|False|False|False
31905260|35424786|0|0|This may not qualify for the complete answer, but if the purpose is to send a message attachment, you can send a CWd JSON structure as the value of the CW parameter, like so ( split into multiple lines for clarity ):|False|purpose is to send attachment |['attachment']|[]|['attachment', 'purpose']|False|False|False|False
31930041|31935351|4|0|POSTSCRIPT: walk/1 is a built-in in versions of jq > 1.5, and can therefore be omitted if your jq includes it, but there is no harm in including it redundantly in a jq script.|False|jq includes it |['jq']|[]|['jq']|False|False|False|False
31930041|37175540|0|0|In principle, if you have access to bash or some other advanced shell, you could do something like|False|you have access to bash or shell |['shell', 'access']|[]|['shell', 'access']|False|False|False|False
31930041|37175540|2|6|Alternatively if you want them to be represented as a set, and the elements are strings, you could put them in objects like CW.|False|you want them to be represented as set |['set']|[]|['set']|False|False|False|False
34287402|52277406|0|2|For example, if the user does not have access to the data URL and gets some HTML instead.|False|user not have access to URL and gets HTML instead . |['access']|['user']|['access', 'user']|False|False|False|False
44655562|50053529|1|0|Some CW structs will be able to parse your CW file just fine if you restructure it using recursive hashes, i.e. if your CW just contains an array of CW which in turn contains ( one or several ) CW.|False|you restructure it using hashes |['hashes']|[]|['hashes']|False|False|False|False
45598461|45603025|2|1|It's easy enough to adapt the code if that's not the case )|False|that not case |['case']|[]|['case']|False|False|False|False
35844138|35845278|1|0|There is a already an LINK for this in the postgres driver Github repository ( even if the problem seems the be the serverside processing ).|False|problem seems the be processing -RRB- |['processing']|[]|['problem', 'processing']|False|False|False|False
41336663|41336869|2|0|Note that if you use Chrome's console you should be able to browse through the object without having to stringify the JSON, which makes it easier to debug.|False|you use 's console you should be able to browse through object without having to stringify JSON |['object', 'console']|[]|['object', 'console']|False|False|False|False
39024354|46159307|3|1|If you have a highly developed modeling, you will more then likely have a set where you think you going to get your intended entity and it's child list, but if those list items also have children, or other parents then you will load those.|False|you have a developed modeling |['modeling']|[]|['modeling']|False|False|False|False
33088462|33094930|0|0|Well, if you just need a single extra property, one simple approach is to parse your JSON to a CW, use CW to populate your class from the CW, and then use CW to pull in the extra property.|False|you just need property |['property']|[]|['property']|False|False|False|False
30101603|43458007|0|0|"FYI, if someone's using jsonb in > = 9.5 and they only care about top-level elements being merged without duplicate keys, then it's as easy as using the | | operator:"|False|'s jsonb in > = 9.5 and they only care about elements being merged without duplicate keys |['jsonb', 'keys', 'elements']|[]|['jsonb', 'keys', 'elements']|False|False|False|False
39406043|52137543|4|1|This mean that you wo n't need to wait until this file will load - as you will if you choice to work with CW - meaning faster application !|False|you choice to work with CW - meaning faster application |['choice', 'application']|[]|['choice', 'application']|False|False|False|False
49645813|49646254|3|0|and if you want it as an array of pairs:|False|you want it as array of pairs : |['pairs', 'array']|[]|['pairs', 'array']|False|False|False|False
34226370|34227629|1|0|CW produces the key names in sorted order ; if you want them in the original order, use CW.|False|you want them in order |['order']|[]|['order']|False|False|False|False
30777419|30778141|0|0|With Retrofit 1.9.0, if you use the Callback asynchronous version of the interface,|False|you use version of interface |['version', 'interface']|['interface']|['version', 'interface', '1.9.0,']|False|False|False|False
34600003|34600032|1|0|For instance, if one of the values is CW, the CW would produce an invalid JSON which can not be loaded:|False|one of values is CW |['values']|[]|['values']|False|False|False|False
29571284|29574160|3|2|So, if a client has a broken implementation, it can write the CW request as a CW, sending the CW method, and you can have a middleware that's decoupled from your application implementation and rewrites the method accordingly.|False|client has implementation |['client', 'implementation']|[]|['client', 'implementation']|False|False|False|False
49996456|51494250|4|0|But if you have an CW property in your CW:|False|you have property in CW : |['property']|[]|['property']|False|False|False|False
47266862|52106099|3|0|Be careful with nested structs: E.g. if you have a property with a custom struct as type, you need to convert that to a dictionary too.|False|you have property with struct as type |['property', 'struct', 'type']|[]|['property', 'struct', 'type']|False|False|False|False
35123835|35183644|2|0|Another benefit of this approach would be if a client wants XML instead of JSON, they would get it.|False|client wants XML of JSON |['client']|[]|['client']|False|False|False|False
34516332|34516875|1|0|However this will not result in any errors if the server sends you bad objects because of 2 reasons.|False|server sends you objects |['server', 'objects']|[]|['server', 'objects']|False|False|False|False
29247235|29840307|1|2|Later, if no items get merged into it, you simply CW it before CW gets added to the main object.|False|items get merged into it |['items']|[]|['items']|False|False|False|False
32942661|32943372|2|1|Members of Items.java can be changed if JSON has other keys.|False|JSON has keys |['keys']|[]|['keys', 'Items.java']|False|False|False|False
51704138|51751913|11|0|As of these releases, if you try and pass a string with an unmatched surrogate pair, Node will replace that character with the unknown unicode character ( U+FFFD ).|False|you try and pass string with pair |['string', 'pair']|[]|['string', 'pair']|False|False|False|False
51704138|51781777|7|1|And you might also want to install CW to efficiently check if a message contains valid UTF-8 as required by the spec.|False|message contains as required by spec |['spec', 'message']|[]|['spec', 'message']|False|False|False|False
31730834|31836226|4|1|However I would recommend that you make the translation slightly different then the json file so you can see if that is the case before adding the force reload.|False|that is case before adding reload |['reload', 'case']|[]|['reload', 'case']|False|False|False|False
32818884|32828120|0|1|It can read some, but not create, especially if you host in IIS.|False|you host in IIS |['host']|[]|['host']|False|False|False|False
32818884|34838334|0|0|I have found if you create the visual studio solution folder on a UNC path this error will occur.|False|you create folder on path |['folder', 'path']|[]|['folder', 'path']|False|False|False|False
40057854|40058055|5|0|The third option CW is important if the root object of the received JSON is not an array and not a dictionary.|False|object of JSON not array and not dictionary |['dictionary', 'array', 'object']|[]|['dictionary', 'array', 'object']|False|False|False|False
38806490|40377740|1|0|So, if you create/upload your own file in Google Storage -- like I'm doing now while trying to test the same API you are using -- the `` equivalence'' is the following:|False|you create/upload file in Storage -- like I 'm doing now while trying to test API you are using -- equivalence '' is following : |['file']|[]|['file', 'following']|False|False|False|False
42395200|42395516|2|0|You could also try generating a new project with the cli with CW and see if it contains the CW file.|False|it contains file |['file']|[]|['file']|False|False|False|False
35709595|38357877|1|3|It is this variability that can be a pain if your application has specific precision requirements.|False|application has requirements |['requirements', 'application']|[]|['requirements', 'application']|False|False|False|False
35709595|38357877|5|0|So if you are wanting to send a precise numeric value to a consumer and you do n't want automatic conversion of the value into the typical internal numeric representation, your best bet is to ship the numeric value out as a string and tell the consumer exactly how that string should be processed if and when numeric operations need to be performed on it.|False|you are wanting to send value to consumer and you n't want conversion of value into representation |['value', 'consumer', 'representation']|[]|['conversion', 'value', 'consumer', 'representation']|False|False|False|False
35709595|38357877|9|3|Simpler for the client to display stuff on screen perhaps, but this can make extracting the numeric value from the string difficult if the client also needs to make computations on the values.|False|client also needs to make computations on values |['client', 'values', 'computations']|[]|['client', 'values', 'computations']|False|False|False|False
31102784|31234613|1|1|It's best if you separate those two steps.|False|you separate steps |['steps']|[]|['steps']|False|False|False|False
31102784|31352212|2|0|Does n't matter if the API is streaming or that we need to connect every X second as that we can take into account ?|False|API is streaming or that we need to connect X second as that we can take into account |['streaming', 'account']|[]|['streaming', 'account']|True|False|False|False
31102784|33598613|1|0|You instantiate it with one line if your push message generation script is on the same server.|False|script is on server |['server', 'script']|[]|['server', 'script']|False|False|False|False
38615482|38749477|2|0|and see if you get a valid response stream.|False|you get stream |['stream']|[]|['stream']|False|False|False|False
35481817|35482323|8|1|This must start with CW ( see above ), so if you wrap it with a bracket ( CW ) it can not be a CW ... But if it matches as CW it must be a CW.|False|you wrap it with bracket -LRB- CW -RRB- it not be CW ... But it matches as CW it must be CW |['bracket']|[]|['bracket']|False|False|False|False
35481817|35482504|3|0|The same applies if you put this into an CW statement.|False|you put this into statement |['statement']|[]|['statement']|False|False|False|False
32071318|32138635|7|0|The whole idea is mapReady is a simple catch ... You can add the if statement to the initialize function.|False|statement |['statement']|[]|['statement', 'mapReady']|False|False|False|False
32071318|32138635|8|0|In past testing, if i load a website from my localhost and have something like google maps.|False|i load website from localhost and have something like maps |['website', 'load', 'maps', 'localhost']|[]|['website', 'load', 'maps', 'something', 'localhost']|False|True|False|False
29044209|29186757|0|0|Does this code pattern create a XSS vulnerability, if an attacker chooses url maliciously ?|False|attacker chooses url maliciously |['url']|[]|['url', 'attacker']|True|False|False|False
29044209|29186757|6|0|To be safe, you have to both set the CW option and, if that option is CW, also the CW option.|False|option is CW |['option']|[]|['option']|False|False|False|False
34660641|34685114|4|1|Please correct me if I'm wrong or if this needs more detail.|False|I 'm wrong or this needs detail |['detail']|[]|['detail']|False|True|False|False
30249406|30266100|0|0|I do n't know if it's the best solution, but what I'm trying now is to just pass values as strings unformatted except for a decimal point, like so:|False|it 's solution |['solution']|[]|['solution']|False|False|False|False
30249406|30266100|7|0|However, it does leave a problem -- what if the app needs to perform calculations and then show the results to the user ?|False|app needs to perform calculations and then show results to user ? |['results', 'calculations']|['user']|['results', 'calculations', 'app', 'user']|True|False|False|False
30249406|53679769|2|0|However it would only be meaningful if any part of the system avoids floating point too.|False|part of system avoids point too |['part', 'point', 'system']|[]|['part', 'point', 'system']|False|False|False|False
33207376|42820141|0|2|What I do is specifically ask if the object responds to a particular method.|False|object responds to method |['method', 'object']|[]|['method', 'object']|False|False|False|False
36354704|50128788|0|1|Or while unwrapping you can assign empty string to property if the value is nil|False|value is nil |['value']|[]|['value', 'nil']|False|False|False|False
36354704|50148332|1|0|If you do not use optional values, you have to control parameters while parsing and add a default value if you want a crash free app.|False|you not use values |['values']|[]|['values']|False|False|False|False
36354704|50148332|1|1|And you would n't know if it was nil or empty string from server.|False|it was nil or empty string from server |['server', 'string']|[]|['server', 'string']|False|False|False|False
38380462|43192024|5|0|Beware: Also, on client side, if you make ajax request and use JSON.parse ( `` OK'' ), it throws Unexpected token ` O'|False|you make request and JSON.parse -LRB- '' -RRB- |['request']|[]|['JSON.parse', 'request']|False|False|False|False
40421100|40423914|3|0|There's no error because CW satisfies type CW because it has all of its properties, and the CW function can be called with no runtime errors even if what it receives is n't an instance of CW as long as it has the same properties.|False|what it receives n't instance of CW long as it has properties |['properties', 'instance']|[]|['properties', 'instance']|False|False|False|False
40421100|40423914|9|0|Then you'll get the error because it's not a string, it's an object, and if you already have it in this form then there's no need to use CW.|False|you already have it in form then there 's need to use CW |['form']|[]|['form', 'need']|False|False|False|False
30125965|30186380|12|0|So if PowerShell is your thing, you could have the best of both worlds:|False|PowerShell is thing |['powershell']|[]|['PowerShell', 'thing']|False|False|False|False
35760096|35760153|1|1|One quick workaround ( if you have the luxury of code generation you can automate this ):|False|you have luxury of generation you can automate this -RRB- |['generation']|[]|['luxury', 'generation']|False|False|False|False
45430535|46525856|6|1|( I did not choose this option because the ` lambda' limits are lower than the Firehose limits, you can configure Firehose to write a file each 128Mb or 15 minutes, but if you associate this lambda function to Firehose, the lambda function will be executed every 3 mins or 5 MB, in my case I had the problem of generate a lot of little parquet files, as for each time that the lambda function is launched I generate at least 10 files ).|False|you associate function to Firehose |['function']|[]|['128Mb', 'function']|False|False|False|False
48535819|48597168|5|2|I believe if the purpose of creating the json file is to import it in some form, at some stage in future, I think you might have to look at the option of just having a csv file instead, which you use to filter out whatever is required at that point of time.|False|purpose of creating file is to import it in form |['file', 'form']|[]|['file', 'purpose', 'form']|False|False|False|False
48535819|48597168|9|0|Even if you get past this point, you will still run into memory issues, due to the way how you are storing everything in $ json variable which is eating up lot of your memory.|False|you get past point |['point']|[]|['point']|False|False|False|False
36141388|36141631|3|1|So if the data is a nested json structure, the function will not return any of the deeper keys.|False|data is structure |['structure']|[]|['structure', 'data']|False|False|False|False
30156407|30225282|4|0|After this exit point assuming the data confirmed to the model, you can validate if the data is within certain limits.|False|data is within limits |['limits']|[]|['limits', 'data']|False|False|False|False
30156407|30355169|2|0|However, if your server delivers public api services then you should validate the calls upfront.|False|server delivers services then you should validate upfront . |['server', 'services']|[]|['server', 'services', 'upfront']|False|False|False|False
34325096|34377323|1|1|So if you hardcode this name you should remember to insert them or you will get error.|False|you hardcode name you should remember to insert them |['name']|[]|['name']|False|False|False|False
36745691|36763214|1|0|However, if you just have a local repo without releases, you have to use:|False|you just have repo without releases |['repo', 'releases']|[]|['repo', 'releases']|False|False|False|False
33122014|33174045|0|1|As others have already pointed out, there is not much you can do to avoid conflicts if you have that high number of changes happening to the config all the time.|False|you have number of changes happening to config time |['time', 'number', 'config']|['time']|['time', 'changes', 'number', 'config']|False|False|False|False
31473215|49726900|1|0|Let me know if you have a sample Dataframe and a format of JSON to convert.|False|you have sample Dataframe and format of JSON to convert |['sample', 'format']|[]|['sample', 'format']|False|False|False|False
47232187|47232318|1|1|That means you do n't have to use CW anymore if you are on the latest release.|False|you are on release |['release']|[]|['release']|False|False|False|False
39065676|39942490|0|3|If just return string CW represent CW what if i want to return string CW instead of CW.|False|just CW represent CW what i want to return CW of CW |['return']|[]|['return']|False|True|False|False
29026596|36774144|0|0|Might be a little bit off-topic, but what happens if the inner object contains a Date property ?|False|object contains property |['property', 'object']|[]|['property', 'object']|True|False|False|False
29164419|36127195|1|0|In pre-marshalling method, you have to pass a modified fields CW to CW function if client's email is CW.|False|'s email is CW |['email']|[]|['email']|False|False|False|False
29164419|36127195|3|1|The CW function by default removes all fields those are CW or you have to explicitly pass the field names if that's not desired and you have to pass CW argument too if CW takes the same.|False|that not desired and you have to pass argument too CW takes same |['argument']|[]|['argument']|False|False|False|False
35444968|35544154|2|3|Hence, if there are 4 addresses and 8 plans, there will be 4 * 8 = 32 rows in the joined data frame.|False|there are addresses and plans |['addresses', 'plans']|[]|['addresses', 'plans']|False|False|False|False
35444968|35574705|1|0|If you want to keep the semantics of the fields, like keep all CWs in a single column, you can normalize your data design a bit, and do joins afterwards, if you need the information together:|False|you want to keep semantics of fields |['fields', 'semantics']|[]|['fields', 'semantics']|False|False|False|False
37816269|52402431|1|0|The first one, CW picks only the first value if there are multiple keys with the same name.|False|there are keys with name |['keys', 'name']|[]|['keys', 'name']|False|False|False|False
37816269|52402431|1|1|If you leave the CW clause, it throws ` Subquery returns more than 1 row' if more keys found ( safe mode ).|False|you leave clause |['clause']|[]|['clause']|False|False|False|False
37816269|52402431|4|1|You can speed up if you prepare a table for the CW subselect.|False|you prepare table for subselect |['table']|[]|['table', 'subselect']|False|False|False|False
37816269|52402431|5|0|Yep, and if you have the chance, try to upgrade to MySQL 5.7, the built-in functions work much more efficiently.|False|you have chance |['mysql']|[]|['chance', 'MySQL']|False|False|False|False
41117918|41148344|2|3|So, if you put JSON into scratch buffer it wo n't get formatted with JSON type formatter.|False|you put JSON into buffer it n't get formatted with formatter . |['buffer', 'formatter']|['buffer']|['buffer', 'formatter']|False|False|False|False
41117918|41148344|3|0|I would encourage you to use scratch files instead of scratch buffers if you want JSON formatting.|False|you want formatting |['formatting']|[]|['formatting']|False|False|False|False
45532477|45963989|1|2|( Also there is a lot that can go wrong if you do operations like this with regex ... )|False|you do operations like this with regex ... |['regex', 'operations']|[]|['regex', 'operations']|False|False|False|False
30030933|30031292|1|0|Or if your CW may include more then one object:|False|CW may include more object : |['object']|[]|['object']|False|False|False|False
30692185|30854521|1|2|You could also be bitten by the provider if they reject requests with parameters they do n't expect.|False|they reject requests with parameters they n't expect |['parameters', 'requests']|[]|['parameters', 'requests']|False|False|False|False
