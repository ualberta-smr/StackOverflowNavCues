True|44396500|44396824|1|0|However one really neat feature of this auto-generated conformance is that if you define a nested CW in your type called `` CW '' ( or use a CW with this name ) that conforms to the LINK protocol -- Swift will automatically use this as the key type . |you define CW in type called `` CW '' -LRB- or use CW with name -RRB- that conforms to protocol |['protocol', 'name', 'type']|[]|['protocol', 'name', 'type']|False|False|False|False
True|44396500|44396824|11|0|In Swift 4.1 , if you rename your CW property to CW , you can take advantage of the key encoding/decoding strategies on CW and CW in order to automatically convert coding keys between CW and CW . |you rename property to CW |['property']|[]|['property']|False|False|False|False
True|44396500|45032910|3|0|Therefore , if the keys used in your serialized data format do n't match the property names from your data type , you can manually implement this enum and set the appropriate CW for the required cases . |keys used in your serialized format n't match names from type |['names', 'format', 'keys', 'type']|[]|['names', 'format', 'keys', 'type']|False|False|False|False
True|29599005|43198481|4|0|Note : if you want CW as a string , it is very simply to convert to a string : CW |you want CW as string |['string']|[]|['string']|False|False|False|False
True|39918814|45286308|3|0|as well if you use date on SQL statement , try to put it inside '' like ' 2017-07-24 ' |you use date on statement |['date', 'statement']|[]|['date', 'statement']|False|False|False|False
True|28547288|28548756|2|0|Then if you 'd access your script using CW instead of CW , the call should succeed . |you 'd access script using CW of CW |['script']|[]|['script']|False|False|False|False
True|28547288|38000615|2|0|You can use it for debugging your app on a local machine ( if everything works in production ) . |everything works in production -RRB- |['production']|[]|['everything', 'production']|False|False|False|False
True|28547288|38000615|3|0|Notice : If URL becomes broken the extension name is LINK . |URL becomes broken name is LINK |['name']|[]|['name']|False|False|False|False
True|44603248|44621628|1|0|Oftentimes , if you reach deep enough into the API 's documentation , you will find the full list of all potential metadata keys . |you reach enough into 's documentation |['documentation']|['documentation']|['documentation']|False|False|False|False
True|44603248|46049763|3|0|EDIT 2 : If you simply want to convert an entire file to a dictionary , you are better off sticking with api from JSONSerialization as I have not figured out a way to extend JSONDecoder itself to directly decode a dictionary . |you simply want to convert file to dictionary |['jsondecoder', 'file', 'jsonserialization', 'dictionary']|[]|['JSONDecoder', 'file', 'JSONSerialization', 'dictionary']|False|False|False|False
True|39423367|39423764|9|0|The only ( rare ) option which is useful in Swift is CW which is required if if the JSON root object could be a value type ( CW , CW , CW or CW ) rather than one of the collection types ( CW or CW ) . |object could be type |['object', 'type']|[]|['object', 'type']|False|False|False|False
True|39423367|39423764|20|0|If you need an item at specific index check also if the index exists |you need item at check also index exists |['index', 'item', 'check']|[]|['index', 'item', 'check']|False|False|False|False
True|39423367|39423781|5|0|Or if you would prefer you can do it in line : |you would prefer you can do it in line : |['line']|[]|['line']|False|False|False|False
True|39423367|54143678|0|1|Lets get rid of `` if let '' or `` guard let '' boilerplate and force unwraps using functional approach : |let '' or `` guard let |['guard']|[]|['guard']|False|False|False|False
True|37280274|44978481|4|1|Hopefully this helps , if you 're looking for a handy way to track down which API response contains a JSON syntax error I 've written an LINK . |you 're looking for way to track down which response contains error I 've written LINK |['response']|['error']|['way', 'error', 'response']|False|False|False|False
False|37280274|52553535|0|1|I even used Postman to check if I had the correct routes or endpoint . |I had routes or endpoint |['routes', 'endpoint']|[]|['routes', 'endpoint']|False|True|False|False
True|36239705|36244111|49|2|It should show you if the json is valid . |json is valid |['json']|[]|['json']|False|False|False|False
True|36239705|36244111|51|1|Note that you may experience crash if certain feature is used . |feature is used |['feature']|['feature']|['feature']|False|False|False|False
False|33660866|40901513|6|0|However , if I use the CW to search this table very frequently , what should I do ? |I use CW to search table frequently |['table']|[]|['table']|True|True|False|False
True|33660866|49576873|2|2|Of course , you can also make one huge transaction if you want , so you 'll get guarantee that MySql will perform `` all or nothing '' , but other applications will most probably not be able to use database during transaction execution . |you want |['mysql']|[]|['MySql']|False|False|False|False
True|33660866|49576873|6|0|So , if we want to just duplicate JSON key in 40 millions rows table , we need to not use table at all during 30-40 hours . |we want to just duplicate JSON key in millions rows table |['rows', 'table']|[]|['rows', 'millions', 'table']|False|False|False|False
True|33660866|49576873|7|1|Virtual generated columns perform much faster , however , if we know our data structure beforehand , we do n't need JSON , we can use traditional columns instead . |we know structure beforehand |['structure']|[]|['structure']|False|False|False|False
False|33660866|51954906|2|0|By analogy , if I 'm searching a telephone book for people with first name `` Bill '' , I still have to read every page in the phone book , even if the first names have been highlighted to make it slightly quicker to spot them . |I 'm searching book for people with '' |['book']|[]|['people', 'book']|False|True|False|False
True|33660866|51954906|5|0|Or even if you query the exact expression that the virtual column is based on ( as in your original query ) , then it can also use the index . |you query expression that column is based on -LRB- as in query -RRB- |['query', 'expression']|[]|['column', 'query', 'expression']|False|False|False|False
True|33660866|51954906|6|2|But it turns out you have to define an extra ( virtual ) column anyway , if you want to search JSON fields with the help of an index . |you want to search fields with help of index |['index', 'fields']|[]|['index', 'fields', 'help']|False|False|False|False
True|28459418|29568747|2|1|This means that if for example only certain attributes are provided , those should be remove ( i.e. set to null ) . |for example attributes are provided |['attributes']|[]|['attributes', 'example']|False|False|False|False
True|28459418|29568747|5|0|Now , if the PUT was designed according the spec , then the PUT would set the username to null and you would get the following back . |PUT was designed according spec |['spec']|[]|['spec']|False|False|False|False
False|28459418|29568747|13|0|Now , I do n't know if I particularly agree with the article as many commentators point out . |I particularly agree with article as commentators point out |['commentators', 'article']|[]|['commentators', 'article']|False|True|False|False
True|28459418|34400076|11|0|Since PUT requests include the entire entity , if you issue the same request repeatedly , it should always have the same outcome ( the data you sent is now the entire data of the entity ) . |you issue request repeatedly |['request']|[]|['request']|False|False|False|False
False|28459418|34400076|12|0|What happens if you use the above PATCH data in a PUT request ? |you use data in request |['request']|[]|['data', 'request']|True|False|False|False
True|28459418|39338329|2|0|The term idempotent is used more comprehensively to describe an operation that will produce the same results if executed once or multiple times -LSB- ... -RSB- An idempotent function is one that has the property f ( f ( x ) ) = f ( x ) for any value x. |executed once or times -RSB- function is one that has property f -LRB- f -LRB- x -RRB- -RRB- = f -LRB- x -RRB- for value x. |['times', 'function', 'property', 'value']|[]|['times', 'function', 'property', 'value', 'x']|False|False|False|False
False|28459418|39338329|8|0|Now , if we issue the exact same PATCH request as above , what happens ? |we issue request above |['request']|[]|['request']|True|False|False|False
True|28459418|44032880|6|1|But if you define operations like : `` increment '' or `` append '' , you can easily see it wo n't be idempotent anymore . |you define operations like : '' or '' |['operations']|[]|['operations']|False|False|False|False
True|28459418|53319895|1|0|A request method is considered `` idempotent '' if the intended effect on the server of multiple identical requests with that method is the same as the effect for a single such request . |effect on server of requests with method is same as effect for request |['method', 'requests', 'server', 'request', 'effect']|[]|['method', 'requests', 'server', 'request', 'effect']|False|False|False|False
True|28459418|53319895|3|0|Idempotent methods are distinguished because the request can be repeated automatically if a communication failure occurs before the client is able to read the server 's response . |failure occurs before client is able to read 's response |['response', 'client']|['failure']|['response', 'failure', 'client']|False|False|False|False
True|28459418|53319895|3|1|For example , if a client sends a PUT request and the underlying connection is closed before any response is received , then the client can establish a new connection and retry the idempotent request . |client sends request and connection is closed before response is received |['connection', 'response', 'client', 'request']|[]|['connection', 'response', 'client', 'request']|False|False|False|False
True|28459418|53319895|3|2|It knows that repeating the request will have the same intended effect , even if the original request succeeded , though the response might differ . |request |['request']|[]|['request']|False|False|False|False
True|28459418|53319895|7|0|If instead the client uses a PUT request to correct the email , sending to the server all properties of user 1 along with the email , his intended effect will be achieved even if the request has to be re-sent later and user 1 has been modified in the meanwhile -- since the second PUT request will overwrite all changes since the first request . |instead client uses request to correct email |['client', 'email', 'request']|[]|['client', 'email', 'request']|False|False|False|False
True|28418662|53225311|0|0|if your json format and variables are okay then check your database queries ... even if data is saved in db correctly the actual problem might be in there ... recheck your queries and try again . |format and variables are okay then check queries ... data is saved in db |['format', 'queries', 'variables']|[]|['format', 'data', 'queries', 'db', 'variables']|False|False|False|False
True|31469441|31470302|6|0|Disadvantage : If you want to fetch single id then you will need to iterate through the array . |you want to fetch id then you will need to iterate through array |['array']|[]|['id', 'array']|False|False|False|False
True|31469441|31509502|0|3|I 'm not sure if this applies to some Java frameworks , too . |this applies to frameworks |['frameworks']|[]|['frameworks']|False|False|False|False
True|29775797|45345813|1|0|However , if you try with jQuery 's CW and it 's working , the reason is probably because of jQuery using CW instead of CW . |you try with 's CW and it 's working |['jquery']|[]|['jQuery']|False|False|False|False
True|29775797|49517293|0|0|I think that , we do n't need parse the JSON object into a string , if the remote server accepts json into they request , just run : |server accepts json into they request |['json', 'json', 'server']|[]|['json', 'JSON', 'server']|False|False|False|False
True|33279153|33359638|4|0|Another option if mixing the alternatives , you can use multipart/form-data but instead of send every value separate , you can send a value named payload with the json payload inside it . |mixing alternatives |['alternatives']|[]|['alternatives']|False|False|False|False
True|28802544|54984848|1|1|It can be as simple as LINK if you are using ISO-8601 values ( `` 2019-01-31 '' ) |you are using values `` 2019-01-31 -RRB- |['values']|[]|['values']|False|False|False|False
True|42360139|42360418|12|0|Note that there are some guides that will try to solve this by `` undoing '' the defaults , rather than just not implementing it in the first place ... If you factor in that we 're now working with Open Source , this is redundant work , bad code and frankly an old habit that will disappear soon . |you factor in that we 're now working with Source |['factor']|['factor']|['factor']|False|False|False|False
True|42360139|42360418|17|0|Forcing a Particular Format If you would like to restrict the response formats for a specific action you can , you can apply the -LSB- Produces -RSB- filter . |you would like to restrict formats for action you can |['action', 'formats']|[]|['action', 'formats']|False|False|False|False
True|42360139|42360418|18|0|The CW filter will force all actions within the CW to return JSON-formatted responses , even if other formatters were configured for the application and the client provided an CW header requesting a different , available format . |formatters were configured for application |['formatters', 'application']|[]|['formatters', 'application']|False|False|False|False
True|33650399|42032709|0|0|json-loader does n't load json file if it 's array , in this case you need to make sure it has a key , for example |it 's array |['array']|[]|['array']|False|False|False|False
True|28957285|45994247|0|0|There are already few answers here , but I would like to add that if you are using CW to Obfuscate your code & do n't use CW in your model class , then your GSON wo n't work . |you are using CW to Obfuscate code & n't use CW in class |['class']|[]|['code', 'class']|False|False|False|False
True|28957285|45994247|2|0|Of Course you can tell proguard to not obfuscate your model , but if you would like to have model obfuscated , then you must specify CW |you would like to have model obfuscated |['model']|[]|['model']|False|False|False|False
True|32960857|32967407|5|2|This will also prevent values being in the wrong columns if some objects have a different key order . |objects have order |['order', 'objects']|[]|['order', 'objects']|False|False|False|False
True|34944099|34946395|1|1|Depending on your needs you can either look into how to read files in JavaScript ( CW could be an option if you 're running in the browser ) or use some other loaders as described in LINK ( assuming you are using NodeJS ) . |you 're running in browser |['browser', 'javascript']|[]|['browser', 'NodeJS', 'JavaScript']|False|False|False|False
True|31096130|31096160|2|0|So if the CW format is what you want , then simply stringify that : |format is what you |['format']|[]|['format']|False|False|False|False
True|37010891|45854566|6|0|You can use CW persistence annotation with CW , if you want it to be ignored by persistence provider . |you want it to be ignored by provider |['provider']|[]|['provider']|False|False|False|False
True|36856232|36856787|8|4|With this , you can check if the file exists . |file exists |['file']|[]|['file']|False|False|False|False
True|36856232|36856787|8|8|the callback will contain a stats object which will be null if the file does not exist . |file not exist |['file']|[]|['file']|False|False|False|False
True|30481979|32956160|0|0|Based on the LINK , the easiest way is to use a CW request which according to the docs either `` adds a new list member or updates the member if the email already exists on the list '' . |email already exists on list |['email', 'list']|[]|['email', 'list']|False|False|False|False
True|30480672|30480777|4|2|Last note : this works only if your value is a String . |value is String |['value']|[]|['value']|False|False|False|False
True|36001695|49575969|0|0|Not sure if anyone still runs into this issue but I was able to address this in a dotnetcore console project ( netcoreapp2 .0 ) via : |anyone still runs into issue but I was able to address this in project -LRB- .0 -RRB- via : |['project']|[]|['anyone', 'issue', 'project']|False|False|False|False
True|31537153|34516075|0|0|This can happen if you have a newline ( or other control character ) in a JSON string literal . |you have newline -LRB- or other character -RRB- in string literal |['string', 'newline', 'character']|[]|['string', 'newline', 'character']|False|False|False|False
True|31537153|43995658|0|0|I 'd recommend you to use a text editor such as Vim to find if there are any ( invisible ) special or escape characters causing this issue . |there are any -LRB- invisible -RRB- special or characters causing issue |['characters']|[]|['characters', 'issue']|False|False|False|False
True|31537153|43995658|1|0|Or if you are using windows , it 's even simple ... just copy-paste the code in windows notepad , and it will most likely show any invisible unwanted escape characters or line breaks etc. . |you are using windows |['windows']|[]|['windows']|False|False|False|False
True|30568353|46601536|1|0|EDIT : And use a protected/package-protected default constructor for parent classes if you have inheritance . |you have inheritance |['inheritance']|[]|['inheritance']|False|False|False|False
True|28646332|28647129|2|1|For example , if the request says it accepts XML , but not JSON , and there is a message converter installed that can transform the list to XML , then XML will be returned . |request says it accepts XML |['request']|[]|['request']|False|False|False|False
True|28646332|38258959|2|1|Spring MVC will setup converters for XML ( using JAXB ) and JSON if Jackson libraries are on he classpath . |libraries are on he |['libraries']|[]|['libraries']|False|False|False|False
True|28164849|36971694|0|0|While both of the above answers work well if key , value are strings , I had a situation to append a string and integer ( jq errors using the above expressions ) |key |['key']|[]|['key']|False|False|False|False
True|29758765|41046591|3|0|... but the constructor will be useful if you want to convert the children json object too . |you want to convert object too |['object']|[]|['object']|False|False|False|False
True|37864542|37897833|2|2|Similarly , it needs to be able to serialize the state of global variables between nodes and sub-jobs in the build , which is what I think is happening for you and I and why it only occurs if you add that additional build step . |you add that additional build step |['step']|[]|['step']|False|False|False|False
True|40574159|40574235|3|1|This only works if the URL provides JSONP ( which is a different subset of JavaScript ) , which this one does n't . |URL provides JSONP -LRB- which is subset of JavaScript -RRB- |['javascript', 'subset']|[]|['JavaScript', 'subset']|False|False|False|False
True|40574159|51019890|0|0|Try to use express.static ( ) if you are using Node.js . |you are using Node.js . |['node.js']|[]|['express.static', 'Node.js']|False|False|False|False
True|40574159|51019890|1|1|For example , if you keep your images , CSS , and JavaScript files in a directory named public , you can do as below − |you keep images |['images', 'javascript']|[]|['images', 'JavaScript']|False|False|False|False
True|42179037|42179082|1|0|Note : If CW is a string , then specify the encoding and remember the CW options as well. : |CW is string |['string']|[]|['string']|False|False|False|False
True|29313687|29330280|1|0|But if you ca n't use a Java class you can use one of these two solutions . |you n't use class you can use one of solutions . |['solutions', 'class']|[]|['solutions', 'class']|False|False|False|False
True|29313687|47345702|0|0|To add on to Andrea 's solution , if you are passing an array of JSONs for instance |you are passing array of JSONs for instance |['instance', 'array']|[]|['instance', 'array']|False|False|False|False
True|29696572|29696688|0|0|you can use push method only if the object is an array : |object is array |['array', 'object']|[]|['array', 'object']|False|False|False|False
True|29696572|41064401|0|0|make sure you push into an Array only and if their is error like Uncaught TypeError : data.push is not a function ** then check for type of data you can do this by consol.log ( data ) hope this will help |their is error like TypeError : data.push not function ** then check for type of data you can do this by consol.log -LRB- data -RRB- hope this will help |['type', 'typeerror', 'function']|['error']|['data.push', 'error', 'type', 'TypeError', 'consol.log', 'data', 'function']|False|False|False|False
True|38388824|38392716|3|4|However , this limitation comes from Java , not Maven , as ( normally ) in Java a class loader will only provide access to a single class definition even if multiple definitions are found on the classpath . |definitions are found on classpath |['definitions', 'classpath']|[]|['definitions', 'classpath']|False|False|False|False
True|31276220|32931094|3|0|You can fix this problem if you are the owner of both domains : |you are owner of domains |['owner']|[]|['domains', 'owner']|False|False|False|False
True|43494824|43495014|4|0|It is perfectly okay to store a complete structure as one bit of information if it is one bit of information actually . |it is bit of information actually |['bit']|[]|['information', 'bit']|False|False|False|False
True|43494824|43495014|5|4|Especially if the same person might occur in many different rows it is definitely wrong to use an XML/JSON approach . |person might occur in rows |['rows', 'person']|[]|['rows', 'person']|False|False|False|False
False|43494824|43612427|0|0|The `` golden rule '' I use , in a hand-wavey sort of way , is that if I need JSON in its raw format , it 's okay to store . |I need JSON in format |['format']|[]|['format']|False|True|False|False
True|43494824|43651382|2|0|Also , most of the json processing if at all the field was queried would be outside the sql environment as sql is just not meant for json processing . |at field was queried |['field']|[]|['field']|False|False|False|False
True|43494824|43674507|11|0|Note that CHECK constraints might slow down your insert/update processes so you might avoid them if you need faster write performance . |you need faster write performance |['performance']|['performance']|['performance']|False|False|False|False
True|43494824|43674507|12|0|Compressed JSON storage If you have large JSON text you can explicitly compress JSON text using built-in COMPRESS function . |you have text you can explicitly compress text |['text', 'compress']|[]|['text', 'COMPRESS']|False|False|False|False
True|28596295|48112890|1|0|From this if a user need message then he can get alert message . |message then |['message']|[]|['message']|False|False|False|False
True|42981409|43056278|1|3|Since CW uses EG ( precision ) , CW removes lower digits of fraction parts and destroys original value even if PHP 's float could hold more precise float value . |'s float could hold precise value |['value', 'float']|[]|['value', 'float']|False|False|False|False
False|29847665|29847711|0|0|I would understand if it was just -LSB- Object -RSB- or -LSB- object -RSB- , but why -LSB- object Object -RSB- ? |it was just Object -RSB- or object -RSB- |['object', 'object']|[]|['Object', 'object']|True|False|False|False
True|31930041|31935351|4|0|POSTSCRIPT : walk/1 is a built-in in versions of jq > 1.5 , and can therefore be omitted if your jq includes it , but there is no harm in including it redundantly in a jq script . |jq includes it |['jq']|[]|['jq']|False|False|False|False
True|31930041|37175540|0|0|In principle , if you have access to bash or some other advanced shell , you could do something like |you have access to bash or shell |['shell', 'access']|[]|['shell', 'access']|False|False|False|False
True|31930041|37175540|1|4|It 's probably also worth noting that if you ca n't use bash you can get the same results with temporary files , it 's just not as clean . |you n't use bash you can get results with files |['files', 'results']|[]|['files', 'results']|False|False|False|False
True|31930041|37175540|2|6|Alternatively if you want them to be represented as a set , and the elements are strings , you could put them in objects like CW . |you want them to be represented as set |['set']|[]|['set']|False|False|False|False
True|31930041|37175540|3|0|From the comment discussion : If you want to get a better idea of why the the json is n't the same , then |you want to get idea of why json n't same |['json']|[]|['idea', 'json']|False|False|False|False
True|44343997|52471434|0|1|json is that it can not be published , and it will be ignored if found in any place other than the top level package . |found in other than package |['package']|[]|['package']|False|False|False|False
True|36184641|36188796|0|0|Even if some class does n't expose an CW method , you can still iterate it with CW statement by providing an extension function CW : |class n't expose method |['method', 'class']|[]|['method', 'class']|False|False|False|False
True|34287402|52277406|0|2|For example , if the user does not have access to the data URL and gets some HTML instead . |user not have access to URL and gets HTML instead . |['access']|['user']|['user', 'access']|False|False|False|False
True|44655562|50053529|1|0|Some CW structs will be able to parse your CW file just fine if you restructure it using recursive hashes , i.e. if your CW just contains an array of CW which in turn contains ( one or several ) CW . |you restructure it using hashes |['hashes']|[]|['hashes']|False|False|False|False
True|29965764|29966016|1|0|then if you need you can also create a list in this way : |you need you can also create list in way |['list']|[]|['way', 'list']|False|False|False|False
True|45598461|45603025|2|1|It 's easy enough to adapt the code if that 's not the case ) |that not case |['case']|[]|['case']|False|False|False|False
True|36307487|52992806|0|0|Yep , double curly brackets is the way to go to achieve this - make sure you have the latest version of Postman ( though if you are still running 2014 code when this feature was introduced , shame on you ! ) |you are still running code when feature was introduced |['feature']|['feature']|['code', 'feature']|False|False|False|False
True|31905260|35424786|0|0|This may not qualify for the complete answer , but if the purpose is to send a message attachment , you can send a CWd JSON structure as the value of the CW parameter , like so ( split into multiple lines for clarity ) : |purpose is to send attachment |['attachment']|[]|['purpose', 'attachment']|False|False|False|False
True|36177629|36178202|4|0|( Note that you might need to change the method name if you want to keep both the first call and this one ) . |you want to keep both call and one |['call']|[]|['call']|False|False|False|False
True|35844138|35845278|1|0|There is a already an LINK for this in the postgres driver Github repository ( even if the problem seems the be the serverside processing ) . |problem seems the be processing -RRB- |['processing']|[]|['processing', 'problem']|False|False|False|False
True|41336663|41336822|1|0|EDIT : If your intention is to get the id and other properties from the result object and you want to see it console to know if its there then you can check with CW and access the property if it does exist : |intention is to get id and properties from object and you want to see it console to know its there |['console', 'properties', 'object']|[]|['id', 'intention', 'console', 'properties', 'object']|False|False|False|False
True|41336663|41336869|2|0|Note that if you use Chrome 's console you should be able to browse through the object without having to stringify the JSON , which makes it easier to debug . |you use 's console you should be able to browse through object without having to stringify JSON |['console', 'object']|[]|['console', 'object']|False|False|False|False
True|39024354|46159307|0|0|It is worth noting that if you do control the json output like with inline CW option , |you do control output like with option |['output', 'option']|[]|['output', 'option']|False|False|False|False
True|39024354|46159307|3|1|If you have a highly developed modeling , you will more then likely have a set where you think you going to get your intended entity and it 's child list , but if those list items also have children , or other parents then you will load those . |you have a developed modeling |['modeling']|[]|['modeling']|False|False|False|False
True|37392733|37393711|1|1|But if there was a two-way linkage between fields , since CW ignores the annotated property , you may avoid the infinite recursion . |there was linkage between fields |['linkage', 'fields']|[]|['linkage', 'fields']|False|False|False|False
True|37392733|37393711|4|0|To recap , if you do n't need those properties in the serialization or deserialization process , you can use CW . |you n't need properties in serialization or process |['serialization', 'process', 'properties']|[]|['serialization', 'process', 'properties']|False|False|False|False
True|40973633|40973702|0|2|For example , if you had a CW java class ( such as shown below ) that corresponded to your json , then your retrofit api could return CW |you had class -LRB- as shown below -RRB- that corresponded to json |['class', 'json']|[]|['class', 'json']|False|False|False|False
True|33088462|33094930|0|0|Well , if you just need a single extra property , one simple approach is to parse your JSON to a CW , use CW to populate your class from the CW , and then use CW to pull in the extra property . |you just need property |['property']|[]|['property']|False|False|False|False
True|29512839|49918845|3|0|Note : If you are adding instances of your custom types ( structs ) into the dictionary make sure your types conform to the CW protocol and if you are adding objects of your custom classes into the dictionary make sure your classes inherit from CW and conform to the CW protocol . |you are adding instances of types -LRB- structs -RRB- into dictionary make sure types conform to protocol |['instances', 'structs', 'types', 'protocol', 'dictionary']|[]|['instances', 'structs', 'types', 'protocol', 'dictionary']|False|False|False|False
True|30101603|43458007|0|0|"FYI , if someone 's using jsonb in > = 9.5 and they only care about top-level elements being merged without duplicate keys , then it 's as easy as using the | | operator : "|'s jsonb in > = 9.5 and they only care about elements being merged without duplicate keys |['jsonb', 'keys', 'elements']|[]|['jsonb', 'keys', 'elements']|False|False|False|False
True|44839753|44842806|0|1|You can check for jackson dependency in your pom.xml in the dependency hierarchy tab if using eclipse . |using eclipse |['eclipse', 'pom.xml']|[]|['eclipse', 'pom.xml']|False|False|False|False
True|31224206|31224444|2|0|But if you are n't thinking about supporting this yet I would simply remove CW from the framework list and your errors will probably go away . |you n't thinking about supporting this yet I would simply remove CW from list and errors will probably go away . |['list']|[]|['errors', 'list']|False|False|False|False
True|39406043|43759870|1|0|Note that if you would have generated with ng new YourAppname - this assets directory exists same line with ` app ' directory , and services should be child directory of app directory . |you would have generated with ng YourAppname - directory exists line with directory |['directory', 'line']|[]|['directory', 'YourAppname', 'line', 'ng']|False|False|False|False
True|39406043|52137543|4|1|This mean that you wo n't need to wait until this file will load - as you will if you choice to work with CW - meaning faster application ! |you choice to work with CW - meaning faster application |['choice', 'application']|[]|['choice', 'application']|False|False|False|False
True|49645813|49646254|3|0|and if you want it as an array of pairs : |you want it as array of pairs : |['pairs', 'array']|[]|['pairs', 'array']|False|False|False|False
True|34226370|34227629|1|0|CW produces the key names in sorted order ; if you want them in the original order , use CW . |you want them in order |['order']|[]|['order']|False|False|False|False
True|35734411|48058950|0|0|Strictly speaking if your API is returning an OK code with no content you should return 204 ( no content ) - Angular would also be happy with this and not try to parse anything . |API is returning code with content |['content']|[]|['code', 'content']|False|False|False|False
True|30777419|30778141|0|0|With Retrofit 1.9.0 , if you use the Callback asynchronous version of the interface , |you use version of interface |['interface', 'version']|['interface']|['interface', 'version', '1.9.0']|False|False|False|False
True|34600003|34600032|1|0|For instance , if one of the values is CW , the CW would produce an invalid JSON which can not be loaded : |one of values is CW |['values']|[]|['values']|False|False|False|False
True|29571284|29574160|0|2|For instance , you have to define if parameters in a JSON body are equivalent to querystring parameters or something else entirely . |parameters in body are equivalent to querystring parameters or something entirely |['parameters']|[]|['body', 'parameters', 'something']|False|False|False|False
True|29571284|29574160|3|2|So , if a client has a broken implementation , it can write the CW request as a CW , sending the CW method , and you can have a middleware that 's decoupled from your application implementation and rewrites the method accordingly . |client has implementation |['implementation', 'client']|[]|['implementation', 'client']|False|False|False|False
True|37486251|37491171|2|0|I do n't know why CW returns a promise ( if anyone can shed light , I 'm interested ) . |anyone can shed light |['light']|[]|['anyone', 'light']|False|False|False|False
True|29003215|29003893|1|0|Edit : If for some reason you really do n't want to make your fields public , you can instead decorate them with the LINK to allow them to be serialized and deserialized : |for reason you really n't want to make fields public |['fields', 'reason']|[]|['fields', 'reason']|False|False|False|False
True|34057851|34057946|1|1|However , if you want to convert a Python structure to a JSON response , use CW : |you want to convert structure to response |['structure', 'response']|[]|['structure', 'response']|False|False|False|False
True|34057851|49403699|4|0|However , if you want to literally do what these examples show and serve JSON data as a download , use CW instead . |you want to literally do what examples show and serve data as download |['download']|[]|['data', 'download', 'examples']|False|False|False|False
True|49996456|51494250|1|0|But if you need to use older versions : |you need to use versions : |['versions']|[]|['versions']|False|False|False|False
True|49996456|51494250|4|0|But if you have an CW property in your CW : |you have property in CW : |['property']|[]|['property']|False|False|False|False
True|29442977|34144457|0|1|The only thing you have to do is to create a JsonObject out of the request String you get , and from there you can continue as if it were JsonObjectRequest . |it were JsonObjectRequest |['jsonobjectrequest', 'jsonobject']|[]|['JsonObjectRequest', 'JsonObject']|False|False|False|False
True|29442977|45167215|1|0|if you have n't made any changes to a previously working code then I suggest checking other parameters such as URL , as the IP address may change if you are using your own Computer as a server ! |you n't made changes to a working code then I suggest checking parameters as URL |['parameters']|[]|['changes', 'code', 'parameters']|False|False|False|False
True|33681978|33684128|2|2|But if your content is already serialized to JSON , Web API has no way of knowing that ; it will happily re-serialize the string , adding extra quotes and backslashes in the process . |content is already serialized to JSON |['content']|[]|['content']|False|False|False|False
True|34485420|34485530|4|0|Note that if you 're developing a web application , it will be way more efficient to store images separately in binary form , and store paths to those images in your JSON or elsewhere . |you 're developing application |['application']|[]|['application']|False|False|False|False
True|30698004|30698135|7|0|JSON dumps are efficient and cross-compatible for many reasons but just taking JSON leads to unexpected results if you want to store and load numpy arrays of any type and any dimension . |you want to store and load arrays of type and dimension |['dimension', 'arrays', 'type']|[]|['dimension', 'arrays', 'type']|False|False|False|False
True|47266862|52106099|1|0|You can do this without the CodingKeys ( if the table attribute names on server side are equal to your struct property names ) . |names on side are equal to names -RRB- |['names']|[]|['names', 'side', 'CodingKeys']|False|False|False|False
True|47266862|52106099|3|0|Be careful with nested structs : E.g. if you have a property with a custom struct as type , you need to convert that to a dictionary too . |you have property with struct as type |['property', 'struct', 'type']|[]|['property', 'struct', 'type']|False|False|False|False
True|47266862|52106099|4|0|The Array extension is required if you want to create an array of MyStruct dictionaries . |you want to create array of dictionaries |['dictionaries', 'array', 'array']|[]|['dictionaries', 'Array', 'array', 'MyStruct']|False|False|False|False
True|35123835|35183644|2|0|Another benefit of this approach would be if a client wants XML instead of JSON , they would get it . |client wants XML of JSON |['client']|[]|['client']|False|False|False|False
True|43827637|43950849|1|0|Besides it 'd be best to bind the event to the document not to the elements if you are adding new CW elements via ajax . |you are adding elements via ajax |['ajax', 'elements']|[]|['ajax', 'elements']|False|False|False|False
True|34516332|34516875|1|0|However this will not result in any errors if the server sends you bad objects because of 2 reasons . |server sends you objects |['objects', 'server']|[]|['objects', 'server']|False|False|False|False
True|29247235|29840307|1|2|Later , if no items get merged into it , you simply CW it before CW gets added to the main object . |items get merged into it |['items']|[]|['items']|False|False|False|False
False|34752200|43743897|0|0|suppose if i put i annotation Expose on top of a variable name or password without SerializedName , it will be serialized AS variable name |i put i annotation Expose on top of name or password without SerializedName |['annotation', 'password', 'name']|[]|['SerializedName', 'annotation', 'password', 'top', 'name']|False|True|False|False
True|34752200|43743897|1|0|But if we put SerializedName like ( `` username '' ) or ( `` password '' ) , they will be serialized with that key |we put SerializedName like `` username -RRB- or `` password -RRB- |['password', 'username']|[]|['password', 'username', 'SerializedName']|False|False|False|False
True|32942661|32943372|2|1|Members of Items.java can be changed if JSON has other keys . |JSON has keys |['keys']|[]|['Items.java', 'keys']|False|False|False|False
True|51704138|51751913|11|0|As of these releases , if you try and pass a string with an unmatched surrogate pair , Node will replace that character with the unknown unicode character ( U+FFFD ) . |you try and pass string with pair |['pair', 'string']|[]|['pair', 'string']|False|False|False|False
True|51704138|51781777|7|1|And you might also want to install CW to efficiently check if a message contains valid UTF-8 as required by the spec . |message contains as required by spec |['spec', 'message']|[]|['spec', 'message']|False|False|False|False
True|51704138|51816363|0|0|It seems your output is having some spaces , If you have any spaces or if you find any special characters please use Unicode to full fill them . |you have spaces or you find characters please Unicode to fill them |['characters', 'fill', 'spaces']|[]|['characters', 'fill', 'spaces']|False|False|False|False
True|32097209|47358999|0|0|To build on the answer from @jbyler , you can strip out the numberLongs using LINK after you get your data - that is if you 're using linux . |you 're using linux |['linux']|[]|['@jbyler', 'numberLongs', 'linux']|False|False|False|False
True|29797946|29798770|6|0|If the JSON parsing is done sporadically , this might not have a noticeable effect on performance , but if used improperly in usage-heavy function it could lead to dramatic increase in response times . |parsing is done sporadically |['parsing']|[]|['parsing']|False|False|False|False
True|29797946|29798770|7|0|It should be noted that every.single.statement of JavaScript code in Node.js is executed only one-at-a-time , no matter if it 's called from the main function or from a callback or from a different module or whatever . |it 's called from function or from callback or from module |['module', 'function', 'javascript', 'node.js', 'callback']|[]|['module', 'function', 'JavaScript', 'Node.js', 'every.single.statement', 'callback']|False|False|False|False
True|38558844|38560184|3|0|Regarding your original question , if you know you have a JSON object at the top level , you can just use : |you know you have object at level |['level', 'object']|[]|['level', 'object']|False|False|False|False
True|31971256|45390797|2|0|You can add more value types in the toDictionary function if you need . |you need |['todictionary']|[]|['toDictionary']|False|False|False|False
True|31671634|31672314|2|0|But you can also insert any character of your liking , which would be useful if the zero code point is used as some form of delimiter . |point is used as form of delimiter |['point', 'form', 'delimiter']|[]|['point', 'form', 'delimiter']|False|False|False|False
True|36143683|36144575|0|0|CW is needed if you want to load a file using http . |you want to load file using http |['file', 'http']|[]|['file', 'http']|False|False|False|False
True|31730834|31836226|0|0|From my experience with angular translate a few different issues could be happening here which is hard to pin down because your environment plays a factor into this , if you had a github repo I could clone I could be certain . |you had repo I could |['repo']|[]|['repo']|False|False|False|False
True|31730834|31836226|1|1|I have run into issues using the filter translation with partial and external file loading , I would strongly recommend if you are going to be using partial loading then you only use attributes for setting your translations such as |you are going to be using loading then you only use attributes for setting translations such as |['attributes', 'translations', 'loading']|[]|['attributes', 'translations', 'loading']|False|False|False|False
True|31730834|31836226|4|1|However I would recommend that you make the translation slightly different then the json file so you can see if that is the case before adding the force reload . |that is case before adding reload |['case', 'reload']|[]|['case', 'reload']|False|False|False|False
True|32818884|32828120|0|1|It can read some , but not create , especially if you host in IIS . |you host in IIS |['host']|[]|['host']|False|False|False|False
True|32818884|34838334|0|0|I have found if you create the visual studio solution folder on a UNC path this error will occur . |you create folder on path |['folder', 'path']|[]|['folder', 'path']|False|False|False|False
True|28478221|28478348|1|0|Or shorter if you do n't want the key : value syntax for literals : |you n't want key : syntax for literals : |['key', 'syntax', 'literals']|[]|['key', 'syntax', 'literals']|False|False|False|False
True|40057854|40058055|5|0|The third option CW is important if the root object of the received JSON is not an array and not a dictionary . |object of JSON not array and not dictionary |['array', 'object', 'dictionary']|[]|['array', 'object', 'dictionary']|False|False|False|False
True|38806490|40377740|1|0|So , if you create/upload your own file in Google Storage -- like I 'm doing now while trying to test the same API you are using -- the `` equivalence '' is the following : |you create/upload file in Storage -- like I 'm doing now while trying to test API you are using -- equivalence '' is following : |['file']|[]|['file', 'following']|False|False|False|False
True|29042622|29043450|1|0|To answer your question : If you do n't want to use json-simple in you project you should use the JSONObject from org.json , because it 's provided by the Android JDK . |you n't want to use json-simple in you project you should use JSONObject from org.json |['jsonobject', 'org.json']|[]|['JSONObject', 'org.json']|False|False|False|False
True|29042622|51939264|2|1|On the other hand , if you know a prebuilt rest service or something similar that supports Android 's JSON even better . |you know service or something similar that supports 's JSON better |['service']|[]|['something', 'service']|False|False|False|False
True|42395200|42395516|2|0|You could also try generating a new project with the cli with CW and see if it contains the CW file . |it contains file |['file']|[]|['file']|False|False|False|False
True|30548822|46422110|2|0|and if they do not have any overlapping ( the same item ) , it would throw CW and this finally causes 406 . |they not have overlapping -LRB- item -RRB- |['item']|[]|['item']|False|False|False|False
False|36258959|36259889|4|0|The final web.config handlers section looks as follows ( notice I decided to keep the initial ` remove ' just in case this caused problems if I migrated to a different web server in the future ) . |I migrated to server in future |['future', 'server']|[]|['future', 'web.config', 'server']|False|True|False|False
True|31527050|31527918|1|0|It is possible to convert integer and float columns back to PHP numbers by setting the MYSQLI_OPT_INT_AND_FLOAT_NATIVE connection option , if using the mysqlnd library . |using library |['library']|[]|['library', 'MYSQLI_OPT_INT_AND_FLOAT_NATIVE']|False|False|False|False
True|35709595|38357877|1|3|It is this variability that can be a pain if your application has specific precision requirements . |application has requirements |['requirements', 'application']|[]|['requirements', 'application']|False|False|False|False
True|35709595|38357877|5|0|So if you are wanting to send a precise numeric value to a consumer and you do n't want automatic conversion of the value into the typical internal numeric representation , your best bet is to ship the numeric value out as a string and tell the consumer exactly how that string should be processed if and when numeric operations need to be performed on it . |you are wanting to send value to consumer and you n't want conversion of value into representation |['value', 'representation', 'consumer']|[]|['value', 'conversion', 'representation', 'consumer']|False|False|False|False
True|35709595|38357877|9|3|Simpler for the client to display stuff on screen perhaps , but this can make extracting the numeric value from the string difficult if the client also needs to make computations on the values . |client also needs to make computations on values |['client', 'computations', 'values']|[]|['client', 'computations', 'values']|False|False|False|False
True|37708638|40294345|0|1|( If on the contrary such functionality exists , I at least have n't been able to discover it after quite a bit of searching ) . |on the contrary functionality exists |['functionality']|['functionality']|['functionality']|False|False|False|False
True|31102784|31234613|1|1|It 's best if you separate those two steps . |you separate steps |['steps']|[]|['steps']|False|False|False|False
True|31102784|31347411|2|0|Polling techniques ( including long-polling , where the server keeps sending `` heartbeat '' to the client as if a non-meaningful response is slowly trickling ) can be used as work-around , but there 's always some interval of time where connection is no longer open , until the next cycle happens . |response is slowly trickling |['response']|[]|['response']|False|False|False|False
False|31102784|31352212|2|0|Does n't matter if the API is streaming or that we need to connect every X second as that we can take into account ? |API is streaming or that we need to connect X second as that we can take into account |['streaming', 'account']|[]|['streaming', 'account']|True|False|False|False
True|31102784|31366071|0|0|Choice 1 ( If you want a reliable system ) : A combination of queuing server ( like AMQP or MQTT etc ) and websocket client like LINK will be robust . |you want system -RRB- |['system']|[]|['system']|False|False|False|False
True|31102784|33598613|1|0|You instantiate it with one line if your push message generation script is on the same server . |script is on server |['script', 'server']|[]|['script', 'server']|False|False|False|False
False|38615482|38749477|0|1|What if their server has cached a bad value and will continue sending you that value until their cache clears ? |server has cached value and will continue sending you that value until cache clears ? |['value', 'cache', 'server']|[]|['value', 'cache', 'server']|True|False|False|False
True|38615482|38749477|2|0|and see if you get a valid response stream . |you get stream |['stream']|[]|['stream']|False|False|False|False
True|35481817|35482323|8|1|This must start with CW ( see above ) , so if you wrap it with a bracket ( CW ) it can not be a CW ... But if it matches as CW it must be a CW . |you wrap it with bracket -LRB- CW -RRB- it not be CW ... But it matches as CW it must be CW |['bracket']|[]|['bracket']|False|False|False|False
True|35481817|35482504|3|0|The same applies if you put this into an CW statement . |you put this into statement |['statement']|[]|['statement']|False|False|False|False
True|32071318|32138635|7|0|The whole idea is mapReady is a simple catch ... You can add the if statement to the initialize function . |statement |['statement']|[]|['mapReady', 'statement']|False|False|False|False
False|32071318|32138635|8|0|In past testing , if i load a website from my localhost and have something like google maps . |i load website from localhost and have something like maps |['maps', 'website', 'localhost', 'load']|[]|['maps', 'website', 'localhost', 'load', 'something']|False|True|False|False
True|29044209|29044240|1|0|The acutal CW is used for convenience when we want to speed up on parsing , so if you are really aware of security use customised CW calls . |you are aware of use customised CW calls |['use']|[]|['use']|False|False|False|False
True|29044209|29179025|6|0|If you want to see what happens if the CORS headers are not set : |you want to see what happens headers not set |['headers']|[]|['headers']|False|False|False|False
False|29044209|29186757|0|0|Does this code pattern create a XSS vulnerability , if an attacker chooses url maliciously ? |attacker chooses url maliciously |['url']|[]|['url', 'attacker']|True|False|False|False
True|29044209|29186757|6|0|To be safe , you have to both set the CW option and , if that option is CW , also the CW option . |option is CW |['option']|[]|['option']|False|False|False|False
False|34660641|34685114|4|1|Please correct me if I 'm wrong or if this needs more detail . |I 'm wrong or this needs detail |['detail']|[]|['detail']|False|True|False|False
True|30249406|30266100|0|0|I do n't know if it 's the best solution , but what I 'm trying now is to just pass values as strings unformatted except for a decimal point , like so : |it 's solution |['solution']|[]|['solution']|False|False|False|False
False|30249406|30266100|7|0|However , it does leave a problem -- what if the app needs to perform calculations and then show the results to the user ? |app needs to perform calculations and then show results to user ? |['calculations', 'results']|['user']|['calculations', 'user', 'results', 'app']|True|False|False|False
True|30249406|53679769|2|0|However it would only be meaningful if any part of the system avoids floating point too . |part of system avoids point too |['system', 'part', 'point']|[]|['system', 'part', 'point']|False|False|False|False
True|30249406|53679769|2|1|Even if the backend is only passing data and not doing any calculation , using floating point would eventually result in what you see ( in the program ) is not what you get ( on the json ) . |backend is only passing data and not doing calculation |['calculation', 'backend']|[]|['data', 'calculation', 'backend']|False|False|False|False
True|33207376|42820141|0|2|What I do is specifically ask if the object responds to a particular method . |object responds to method |['method', 'object']|[]|['method', 'object']|False|False|False|False
False|33207376|42820141|0|3|For example if I am looping through parsing some JSON and I am attempting to access a value of type CW : |I am looping through parsing JSON and I am attempting to access value of CW |['value']|[]|['value']|False|True|False|False
True|36354704|50128788|0|1|Or while unwrapping you can assign empty string to property if the value is nil |value is nil |['value']|[]|['value', 'nil']|False|False|False|False
True|36354704|50148332|1|0|If you do not use optional values , you have to control parameters while parsing and add a default value if you want a crash free app . |you not use values |['values']|[]|['values']|False|False|False|False
True|36354704|50148332|1|1|And you would n't know if it was nil or empty string from server . |it was nil or empty string from server |['string', 'server']|[]|['string', 'server']|False|False|False|False
True|36354704|50187959|0|0|Yes , you should use optional if the property is not necessary in API and if you want some value in the mandatory property then assign blank value : |property not necessary in API and you want value in property then assign value |['value', 'property']|[]|['value', 'property']|False|False|False|False
False|36354704|50234940|1|0|Because I know that I 'm going to need to return an error if I do n't get the minimum required parameters , you would need something like an Error enum : |I n't get minimum required parameters |['minimum', 'parameters']|[]|['minimum', 'parameters']|False|True|False|False
True|36354704|50571815|1|0|So keep the required properties as non-optionals and create object only if they are present in the response ( you can use if-let or gaurd-let to check this in response ) , else fail the creation of the object . |they are present in response -LRB- you can use if-let or gaurd-let to check this in response -RRB- |['response']|[]|['response']|False|False|False|False
True|38380462|43192024|5|0|Beware : Also , on client side , if you make ajax request and use JSON.parse ( `` OK '' ) , it throws Unexpected token ` O ' |you make request and JSON.parse -LRB- '' -RRB- |['request']|[]|['JSON.parse', 'request']|False|False|False|False
True|42245288|42257772|1|0|On the other hand , if ( as @NicHuang asked ) you want to add the JSON object to the beginning of the array , you could use the pattern : |-LRB- as @NicHuang asked -RRB- you want to add object to beginning of array |['array', 'object']|[]|['beginning', 'array', '@NicHuang', 'object']|False|False|False|False
True|40421100|40423914|3|0|There 's no error because CW satisfies type CW because it has all of its properties , and the CW function can be called with no runtime errors even if what it receives is n't an instance of CW as long as it has the same properties . |what it receives n't instance of CW long as it has properties |['instance', 'properties']|[]|['instance', 'properties']|False|False|False|False
True|40421100|40423914|9|0|Then you 'll get the error because it 's not a string , it 's an object , and if you already have it in this form then there 's no need to use CW . |you already have it in form then there 's need to use CW |['form']|[]|['form', 'need']|False|False|False|False
True|40421100|40423914|10|0|But , as I wrote , if you 're going with this way then you wo n't have an instance of the class , just an object that has the same properties as the class members . |you 're going with way then you n't have instance of class |['instance', 'class']|[]|['instance', 'way', 'class']|False|False|False|False
True|30082277|44479726|3|0|Note that if you want to specify the entire contents of a page , an identifier such as CW is LINK . |you want to specify contents of page |['page', 'contents']|[]|['page', 'contents']|False|False|False|False
True|29858248|29901800|1|0|which would return the value at given path , or , if path is missing , 0 ( default value ) |path is missing |['path']|[]|['path']|False|False|False|False
True|30943675|30968249|2|0|Works fine with me ( If I replace `` Banner '' with `` banner '' - got wrong object with null `` banner '' field . ) |I replace `` Banner '' `` banner '' - got object with null '' field . |['banner', 'field', 'banner', 'object']|[]|['banner', 'field', 'Banner', 'object']|False|False|False|False
True|30943675|31045976|0|0|I would suggest below ; ( If you are using ObjectMapper ) |you are using ObjectMapper -RRB- |['objectmapper']|[]|['ObjectMapper']|False|False|False|False
True|30125965|30186380|12|0|So if PowerShell is your thing , you could have the best of both worlds : |PowerShell is thing |['powershell']|[]|['PowerShell', 'thing']|False|False|False|False
True|30125965|30317694|3|0|This ensures that even if the manifest for the locale does n't contain the translation yet we still populate it with the English US version . |the manifest for locale n't contain translation yet we still populate it with version |['locale', 'version', 'translation']|[]|['locale', 'version', 'translation']|False|False|False|False
True|28807919|52091341|0|2|It returns true if the list is empty otherwise it gives false . |list is otherwise it gives false |['list']|[]|['list']|False|False|False|False
True|46733354|47864172|2|0|Furthermore , if you are making any request when the component is about to load then simply replace CW with CW and change the render function like so : |you are making request when component is about to load then simply |['request', 'component']|[]|['request', 'component']|False|False|False|False
True|35760096|35760153|1|1|One quick workaround ( if you have the luxury of code generation you can automate this ) : |you have luxury of generation you can automate this -RRB- |['generation']|[]|['generation', 'luxury']|False|False|False|False
True|33457654|33457818|1|1|In your controller you are specifying it accepts JSON , but you have not said if the request indicated that the body is in that format . |request indicated that body is in format |['format', 'request']|[]|['format', 'body', 'request']|False|False|False|False
True|33457654|38801498|1|0|For example , if the Content-Type in request Header was one of application/json or application/xml , that means the POST body contains json or XML -LSB- Popular formats -RSB- , and if Jackson library is found in your classpath , Spring will delegate the conversion to MappingJackson2HttpMessageConverter -LSB- for json -RSB- or MappingJackson2XmlHttpMessageConverter -LSB- for xml -RSB- . |Content-Type in Header was one of application/json or application/xml |['xml', 'xml', 'json']|[]|['MappingJackson2HttpMessageConverter', 'xml', 'XML', 'MappingJackson2XmlHttpMessageConverter', 'json']|False|False|False|False
True|43718733|43719269|1|1|Because Postgres does n't know how to compare two arrays of JSON values , it ca n't decide if your CW produced duplicates . |CW produced duplicates |['duplicates']|[]|['duplicates']|False|False|False|False
True|43718733|43719269|3|0|As pointed out in comments , if you do want to remove duplicates , you can cast the values to something which has a comparison operator defined . |you do want to remove duplicates |['duplicates']|[]|['duplicates']|False|False|False|False
True|29347092|29347148|4|0|Also note that although your example contained only CW values , but if the value type is varying ( e.g. CW , numbers etc. ) , you may use CW for the value type , in which case your map would be of type CW . |type is varying |['type']|[]|['type']|False|False|False|False
True|28405545|50467797|0|1|JsonObject is working fine but if you still want to use JSONObject instead of JsonObject then you can use it that way : |you still want to use JSONObject of JsonObject then |['jsonobject', 'jsonobject']|[]|['JSONObject', 'JsonObject']|False|False|False|False
True|45430535|46525856|6|1|( I did not choose this option because the ` lambda ' limits are lower than the Firehose limits , you can configure Firehose to write a file each 128Mb or 15 minutes , but if you associate this lambda function to Firehose , the lambda function will be executed every 3 mins or 5 MB , in my case I had the problem of generate a lot of little parquet files , as for each time that the lambda function is launched I generate at least 10 files ) . |you associate function to Firehose |['function']|[]|['function', '128Mb']|False|False|False|False
True|48535819|48597168|5|2|I believe if the purpose of creating the json file is to import it in some form , at some stage in future , I think you might have to look at the option of just having a csv file instead , which you use to filter out whatever is required at that point of time . |purpose of creating file is to import it in form |['form', 'file']|[]|['purpose', 'form', 'file']|False|False|False|False
True|48535819|48597168|9|0|Even if you get past this point , you will still run into memory issues , due to the way how you are storing everything in $ json variable which is eating up lot of your memory . |you get past point |['point']|[]|['point']|False|False|False|False
True|48535819|48717328|8|0|Not sure what is the frequency of execution here , but if it is low you can consider your data dumping script to be run through a PHP-CLI instead of HTTP . |it is low you can consider data dumping script to be run through PHP-CLI of HTTP . |['script']|[]|['data', 'script']|False|False|False|False
True|36141388|36141631|1|0|( Or just CW if you 're using just json . ) |you 're using json |['json']|[]|['json']|False|False|False|False
True|36141388|36141631|3|1|So if the data is a nested json structure , the function will not return any of the deeper keys . |data is structure |['structure']|[]|['structure', 'data']|False|False|False|False
True|33895076|33899437|2|0|The following example may be of interest to anyone who wants safe CSV ( i.e. even if the values have embedded commas or newline characters ) : |values have embedded commas or characters |['characters', 'commas', 'values']|[]|['characters', 'commas', 'values']|False|False|False|False
True|33447334|33447629|4|1|This will work if you do n't specify CW in your declaration of CW . |you n't specify CW in declaration of CW |['declaration']|[]|['declaration']|False|False|False|False
True|30156407|30225282|4|0|After this exit point assuming the data confirmed to the model , you can validate if the data is within certain limits . |data is within limits |['limits']|[]|['data', 'limits']|False|False|False|False
True|30156407|30344043|1|0|In other words , only if you are trying to stream JSON and process it on the fly , you will need to think about second option . |you are trying to JSON and process it on fly |['process']|[]|['fly', 'process']|False|False|False|False
True|30156407|30354106|1|0|If efficiency is your goal and you want to validate every single request , it would be ideal if you could evaluate on the front-end if you are using JavaScript you can use LINK . |efficiency is goal and you want to validate request |['goal', 'javascript', 'request']|['efficiency']|['goal', 'efficiency', 'JavaScript', 'request']|False|False|False|False
True|30156407|30355169|2|0|However , if your server delivers public api services then you should validate the calls upfront . |server delivers services then you should validate upfront . |['services', 'server']|[]|['upfront', 'services', 'server']|False|False|False|False
True|34325096|34377323|1|1|So if you hardcode this name you should remember to insert them or you will get error . |you hardcode name you should remember to insert them |['name']|[]|['name']|False|False|False|False
True|46991237|46991300|6|0|This solution has one clear adventage over other solutions provided here - it does n't require you to rebuild entire application if your json will change ( it 's loaded dynamically from a separate file , so you can modify only that file ) . |json will change |['json']|[]|['json']|False|False|False|False
True|30981565|31913188|0|0|Well to be clear if you are releasing your app to devices with ART you will have a huge speed advantage trough parsing . |you are releasing app to devices with ART you will have parsing |['parsing', 'devices']|[]|['parsing', 'devices', 'app']|False|False|False|False
True|40995251|49786064|2|1|If you are running test in AWS itself , be sure to check CloudWatch logs as in lambda it wont output full JSON file if its too long . |you are running test in AWS itself |['test', 'cloudwatch']|[]|['test', 'CloudWatch']|False|False|False|False
True|42426549|42453067|1|1|This is no longer the case if you are starting via a local driver provider . |you are starting via provider |['provider']|[]|['provider']|False|False|False|False
False|42426549|42453067|3|1|How do you check if the binaries are there ? |binaries are there |['binaries']|[]|['binaries']|True|False|False|False
True|36745691|36763214|1|0|However , if you just have a local repo without releases , you have to use : |you just have repo without releases |['releases', 'repo']|[]|['releases', 'repo']|False|False|False|False
True|33122014|33168942|2|2|It is easier if you are running a Javascript project . |you are running project |['project']|[]|['project']|False|False|False|False
True|33122014|33174045|0|1|As others have already pointed out , there is not much you can do to avoid conflicts if you have that high number of changes happening to the config all the time . |you have number of changes happening to config time |['number', 'time', 'config']|['time']|['changes', 'number', 'time', 'config']|False|False|False|False
True|33122014|33262179|1|0|This should n't be the case , you only get conflicts if same line is modified by different people , committed and then later merged . |line is modified by people |['line']|[]|['line', 'people']|False|False|False|False
True|33122014|33296381|0|2|In order to find out , you can open a json file with a Hex editor and see if all line endings are consistent across the whole file . |endings are consistent across file |['file']|[]|['endings', 'file']|False|False|False|False
True|31473215|49726900|1|0|Let me know if you have a sample Dataframe and a format of JSON to convert . |you have sample Dataframe and format of JSON to convert |['format', 'sample']|[]|['format', 'sample']|False|False|False|False
True|47232187|47232318|1|1|That means you do n't have to use CW anymore if you are on the latest release . |you are on release |['release']|[]|['release']|False|False|False|False
True|36318849|42605156|0|1|The inheritance model will vary by language during export from swagger specifically , but in practice method definitions specify the acceptable parameter types using the base model if you want to be able to accept multiple subclasses that inherit the same base model . |you want to be able to accept subclasses that inherit model |['subclasses', 'model']|[]|['subclasses', 'model']|False|False|False|False
False|39065676|39942490|0|3|If just return string CW represent CW what if i want to return string CW instead of CW . |just CW represent CW what i want to return CW of CW |['return']|[]|['return']|False|True|False|False
False|29026596|36774144|0|0|Might be a little bit off-topic , but what happens if the inner object contains a Date property ? |object contains property |['property', 'object']|[]|['property', 'object']|True|False|False|False
True|29164419|36127195|1|0|In pre-marshalling method , you have to pass a modified fields CW to CW function if client 's email is CW . |'s email is CW |['email']|[]|['email']|False|False|False|False
True|29164419|36127195|3|1|The CW function by default removes all fields those are CW or you have to explicitly pass the field names if that 's not desired and you have to pass CW argument too if CW takes the same . |that not desired and you have to pass argument too CW takes same |['argument']|[]|['argument']|False|False|False|False
True|35444968|35519498|13|1|Additionally , it has no package dependencies , parameterizes the column name building logic , and forwards variadic arguments to CW , so for example you can pass CW to inhibit the automatic factorization of character columns normally done by CW , and/or CW to set the row names of the resulting data.frame , or CW to prevent the use of the top-level list component names as row names , if such existed in the input list . |such existed in list |['list']|[]|['list', 'data.frame']|False|False|False|False
True|35444968|35544154|2|3|Hence , if there are 4 addresses and 8 plans , there will be 4 * 8 = 32 rows in the joined data frame . |there are addresses and plans |['addresses', 'plans']|[]|['addresses', 'plans']|False|False|False|False
True|35444968|35574705|1|0|If you want to keep the semantics of the fields , like keep all CWs in a single column , you can normalize your data design a bit , and do joins afterwards , if you need the information together : |you want to keep semantics of fields |['semantics', 'fields']|[]|['semantics', 'fields']|False|False|False|False
True|33423853|33579524|4|0|or if you want this without jQuery , which is same as what @daniel - flint recommended . |you want this without jQuery |['jquery']|[]|['@daniel', 'jQuery']|False|False|False|False
True|37816269|52402431|0|4|They return CW if no value found . |value found |['value']|[]|['value']|False|False|False|False
True|37816269|52402431|1|0|The first one , CW picks only the first value if there are multiple keys with the same name . |there are keys with name |['keys', 'name']|[]|['keys', 'name']|False|False|False|False
True|37816269|52402431|1|1|If you leave the CW clause , it throws ` Subquery returns more than 1 row ' if more keys found ( safe mode ) . |you leave clause |['clause']|[]|['clause']|False|False|False|False
True|37816269|52402431|4|1|You can speed up if you prepare a table for the CW subselect . |you prepare table for subselect |['table']|[]|['subselect', 'table']|False|False|False|False
True|37816269|52402431|5|0|Yep , and if you have the chance , try to upgrade to MySQL 5.7 , the built-in functions work much more efficiently . |you have chance |['mysql']|[]|['chance', 'MySQL']|False|False|False|False
True|31822877|53006093|1|0|It 's a better solution if you do n't know what timezone is used on a server environment . |you n't know what timezone is used on environment |['timezone', 'environment']|[]|['timezone', 'environment']|False|False|False|False
True|29284266|52163011|0|2|( But even if you did store the data in Base64 string , there is no need concern yourself about encoding/decoding performance because the IO 's impact will be more significant . ) |you did store data in string |['string']|[]|['data', 'string']|False|False|False|False
False|29223683|29247219|0|0|I made some minor modification to you code and tested it with a spring project that I have and it works , The logic will only work with POST if I use GET it throws an error with invalid request . |I use GET it throws error with request |['request']|['error']|['error', 'request']|False|True|False|False
True|41117918|41148344|2|3|So , if you put JSON into scratch buffer it wo n't get formatted with JSON type formatter . |you put JSON into buffer it n't get formatted with formatter . |['formatter', 'buffer']|['buffer']|['formatter', 'buffer']|False|False|False|False
True|41117918|41148344|3|0|I would encourage you to use scratch files instead of scratch buffers if you want JSON formatting . |you want formatting |['formatting']|[]|['formatting']|False|False|False|False
True|46559268|47872396|1|0|Angular will only parse the response if the response type is set to `` json '' ( you can see this on line 183 ) . |type is set `` json '' -LRB- you can see this on 183 -RRB- |['type']|[]|['type']|False|False|False|False
True|27907633|47958749|4|0|And if you wanted to append the data instead of writing a new file just change ' mode = `` w '' ' to ' mode = `` a '' ' . |you wanted to append data of writing just ' mode = `` w '' ' to ' mode = `` a '' ' . |['mode']|[]|['mode', 'data']|False|False|False|False
True|27907633|47958749|6|0|On that note if you change you mind at some point and you want a list out of the reader , Python allows you to put a generator function inside of a list and populate the list automatically . |you change you mind at point and you want list out of reader |['point', 'list', 'reader']|[]|['point', 'list', 'reader']|False|False|False|False
True|27907633|47958749|7|1|Sorry if it was a bit verbose . |it was bit verbose . |['bit']|[]|['bit']|False|False|False|False
False|32042938|32091205|0|0|Not sure if I 've understood you correctly , but it sounds like you 're trying to find a simple way of converting POJOs to JsonObject ? |I 've understood you correctly |['jsonobject']|[]|['JsonObject']|True|True|False|False
True|32042938|47358623|1|0|While I agree that if a protocol layer was included in Vert.x it would indeed be first prize , using Gson keeps your server internals pretty organised and is unlikely to be the performance bottleneck . |layer was included in Vert.x it would indeed be prize |['layer']|[]|['layer', 'prize']|False|False|False|False
True|46954692|46955018|2|0|Sets the exit status of jq to 0 if the last output values was neither false nor null , 1 if the last output value was either false or null , or 4 if no valid result was ever produced . |values was |['values']|[]|['values']|False|False|False|False
True|46954692|46955018|4|0|In fact , if you do n't care about distinguishing between the different types of error , then you can just lose the CW switch . |you n't care about distinguishing between types of error |['types']|['error']|['error', 'types']|False|False|False|False
True|45532477|45963989|1|2|( Also there is a lot that can go wrong if you do operations like this with regex ... ) |you do operations like this with regex ... |['operations', 'regex']|[]|['operations', 'regex']|False|False|False|False
True|45532477|45963989|6|0|But I recommend just upgrading your MySQL installation if possible . ||['mysql']|[]|['MySQL']|False|False|False|False
True|34421779|34469643|2|0|BTW : You are directly calling CW , which is very dangerous , if the product does not contain any elements , your code will break . |product not contain elements |['product', 'elements']|[]|['product', 'elements']|False|False|False|False
True|30030933|30031292|1|0|Or if your CW may include more then one object : |CW may include more object : |['object']|[]|['object']|False|False|False|False
True|38993265|39040460|0|0|XML with LINK ( standard library ) or LINK if you are OK with the markup overhead : |you are OK with overhead : |['overhead']|[]|['overhead']|False|False|False|False
True|36003023|36008538|3|0|In this case I believe you can use the CW to write to an open binary file ; however if you need to do something more complicated with the resulting object , you probably need the above code . |you need to do something complicated with object |['object']|[]|['object', 'something']|False|False|False|False
True|30692185|30744774|2|0|LINK which allows you to get the last modification date of a file , so when it is created , you can rely on this information to see if your cache is outdated like you tried to implement it . |cache is outdated like you tried to implement it |['cache']|[]|['cache']|False|False|False|False
True|30692185|30854521|1|2|You could also be bitten by the provider if they reject requests with parameters they do n't expect . |they reject requests with parameters they n't expect |['requests', 'parameters']|[]|['requests', 'parameters']|False|False|False|False
