IsInsightFulIf?|QuestionId|AnswerID|ParagraphIndex|SentenceIndex|Sentence|TruePositive?|Condition|Tags In Condition|NFReqs|Nouns|IsInterrogative?|IsFirstPerson?|IsUnsurePhrase?|HasValidVbDep?|HasValidNounDep?|HasWantedGrammerDep?
False|33279153|33359638|4|0|Another option if mixing the alternatives, you can use multipart/form-data but instead of send every value separate, you can send a value named payload with the json payload inside it.|False|mixing alternatives |['alternatives']|[]|['alternatives']|False|False|False|False|False|False
True|46344963|55428632|1|0|In this case, if one of the element in CW is nil, the whole object is nil while decoding.|False|one of element in CW is nil |['element']|[]|['element', 'nil']|False|False|False|False|True|True
False|46344963|58234393|2|0|Note: The property wrapper things will only works if the response can be wrapped in a struct ( i.e: not a top level array ).|False|response can be wrapped in struct -LRB- i.e : array -RRB- |['struct', 'array', 'response']|[]|['struct', 'array', 'response']|False|False|False|False|False|False
False|39918814|45286308|3|0|as well if you use date on SQL statement, try to put it inside'' like' 2017-07-24'|True|you use date on statement |['date', 'statement']|[]|['date', 'statement']|False|False|False|False|False|False
True|39918814|58207391|0|0|Also worth checking is if there are any errors in the return type of your interface methods.|False|there are errors in type of methods |['type', 'methods']|[]|['errors', 'type', 'methods']|False|False|False|True|False|True
False|44603248|44621628|1|0|Oftentimes, if you reach deep enough into the API's documentation, you will find the full list of all potential metadata keys.|False|you reach enough into 's documentation |['documentation']|['documentation']|['documentation']|False|False|False|True|False|True
False|44603248|46049763|3|0|EDIT 2: If you simply want to convert an entire file to a dictionary, you are better off sticking with api from JSONSerialization as I have not figured out a way to extend JSONDecoder itself to directly decode a dictionary.|True|you simply want to convert file to dictionary |['file', 'dictionary']|[]|['file', 'dictionary']|False|False|False|False|False|False
False|33660866|49576873|6|0|So, if we want to just duplicate JSON key in 40 millions rows table, we need to not use table at all during 30-40 hours.|True|we want to just duplicate JSON key in millions rows table |['table', 'rows']|[]|['table', 'millions', 'rows']|False|False|False|False|False|False
True|33660866|49576873|7|1|Virtual generated columns perform much faster, however, if we know our data structure beforehand, we do n't need JSON, we can use traditional columns instead.|True|we know structure beforehand |['structure']|[]|['structure']|False|False|False|True|False|True
False|33660866|51954906|5|0|Or even if you query the exact expression that the virtual column is based on ( as in your original query ), then it can also use the index.|True|you query expression that column is based on -LRB- as in query -RRB- |['expression', 'query']|[]|['expression', 'query', 'column']|False|False|False|True|False|True
False|33660866|51954906|6|2|But it turns out you have to define an extra ( virtual ) column anyway, if you want to search JSON fields with the help of an index.|True|you want to search fields with help of index |['index', 'fields']|[]|['help', 'index', 'fields']|False|False|False|False|False|False
False|28459418|29568747|2|1|This means that if for example only certain attributes are provided, those should be remove ( i.e. set to null ).|False|for example attributes are provided |['attributes']|[]|['example', 'attributes']|False|False|False|False|False|False
False|28459418|29568747|5|0|Now, if the PUT was designed according the spec, then the PUT would set the username to null and you would get the following back.|True|PUT was designed according spec |['spec']|[]|['spec']|False|False|False|False|False|False
False|28459418|34400076|11|0|Since PUT requests include the entire entity, if you issue the same request repeatedly, it should always have the same outcome ( the data you sent is now the entire data of the entity ).|True|you issue request repeatedly |['request']|[]|['request']|False|False|False|True|False|True
False|28459418|39338329|2|0|The term idempotent is used more comprehensively to describe an operation that will produce the same results if executed once or multiple times -LSB- ... -RSB- An idempotent function is one that has the property f ( f ( x ) ) = f ( x ) for any value x.|True|executed once or times -RSB- function is one that has property f -LRB- f -LRB- x -RRB- -RRB- = f -LRB- x -RRB- for value x. |['times', 'value', 'property', 'function']|[]|['x', 'times', 'value', 'property', 'function']|False|False|False|False|False|False
False|28459418|44032880|6|1|But if you define operations like: `` increment'' or `` append'', you can easily see it wo n't be idempotent anymore.|True|you define operations like : '' or '' |['operations']|[]|['operations']|False|False|False|True|False|True
False|28459418|53319895|1|0|A request method is considered `` idempotent'' if the intended effect on the server of multiple identical requests with that method is the same as the effect for a single such request.|True|effect on server of requests with method is same as effect for request |['server', 'effect', 'requests', 'request', 'method']|[]|['server', 'effect', 'requests', 'request', 'method']|False|False|False|False|False|False
True|28459418|53319895|3|0|Idempotent methods are distinguished because the request can be repeated automatically if a communication failure occurs before the client is able to read the server's response.|True|failure occurs before client is able to read 's response |['response', 'client']|['failure']|['response', 'client', 'failure']|False|False|False|True|False|True
True|28459418|53319895|3|1|For example, if a client sends a PUT request and the underlying connection is closed before any response is received, then the client can establish a new connection and retry the idempotent request.|True|client sends request and connection is closed before response is received |['response', 'client', 'request', 'connection']|[]|['response', 'client', 'request', 'connection']|False|False|False|True|False|True
False|28459418|53319895|3|2|It knows that repeating the request will have the same intended effect, even if the original request succeeded, though the response might differ.|True|request |['request']|[]|['request']|False|False|False|False|False|False
True|28459418|53319895|7|0|If instead the client uses a PUT request to correct the email, sending to the server all properties of user 1 along with the email, his intended effect will be achieved even if the request has to be re-sent later and user 1 has been modified in the meanwhile -- since the second PUT request will overwrite all changes since the first request.|True|instead client uses request to correct email |['client', 'request', 'email']|[]|['client', 'request', 'email']|False|False|False|True|False|True
False|36239705|36244111|49|2|It should show you if the json is valid.|False|json is valid |['json']|[]|['json']|False|False|False|False|False|False
False|36239705|36244111|51|1|Note that you may experience crash if certain feature is used.|False|feature is used |['feature']|['feature']|['feature']|False|False|False|False|False|False
True|39423367|39423764|9|0|The only ( rare ) option which is useful in Swift is CW which is required if if the JSON root object could be a value type ( CW, CW, CW or CW ) rather than one of the collection types ( CW or CW ).|True|object could be type |['type', 'object']|[]|['type', 'object']|False|False|False|False|True|True
True|39423367|39423764|20|0|If you need an item at specific index check also if the index exists|True|you need item at check also index exists |['check', 'index', 'item']|[]|['check', 'index', 'item']|False|False|False|True|False|True
False|39423367|39423781|5|0|Or if you would prefer you can do it in line:|False|you would prefer you can do it in line : |['line']|[]|['line']|False|False|False|False|False|False
False|39423367|54143678|0|1|Lets get rid of `` if let'' or `` guard let'' boilerplate and force unwraps using functional approach:|False|let '' or `` guard let |['guard']|[]|['guard']|False|False|False|False|False|False
False|37280274|44978481|4|1|Hopefully this helps, if you're looking for a handy way to track down which API response contains a JSON syntax error I've written an LINK.|False|you 're looking for way to track down which response contains error I 've written LINK |['response']|['error']|['way', 'error', 'response']|False|False|False|False|False|False
False|28418662|53225311|0|0|if your json format and variables are okay then check your database queries ... even if data is saved in db correctly the actual problem might be in there ... recheck your queries and try again.|False|format and variables are okay then check queries ... data is saved in db |['variables', 'queries', 'format']|[]|['variables', 'data', 'queries', 'db', 'format']|False|False|False|False|False|False
False|28547288|28548756|2|0|Then if you'd access your script using CW instead of CW, the call should succeed.|True|you 'd access script using CW of CW |['script']|[]|['script']|False|False|False|False|False|False
False|28547288|38000615|2|0|You can use it for debugging your app on a local machine ( if everything works in production ).|False|everything works in production -RRB- |['production']|[]|['production', 'everything']|False|False|False|True|False|True
False|28547288|38000615|3|0|Notice: If URL becomes broken the extension name is LINK.|False|URL becomes broken name is LINK |['name']|[]|['name']|False|False|False|False|False|False
False|44396500|44396824|1|0|However one really neat feature of this auto-generated conformance is that if you define a nested CW in your type called `` CW'' ( or use a CW with this name ) that conforms to the LINK protocol -- Swift will automatically use this as the key type.|True|you define CW in type called `` CW '' -LRB- or use CW with name -RRB- that conforms to protocol |['name', 'type', 'protocol']|[]|['name', 'type', 'protocol']|False|False|False|True|False|True
False|44396500|44396824|11|0|In Swift 4.1, if you rename your CW property to CW, you can take advantage of the key encoding/decoding strategies on CW and CW in order to automatically convert coding keys between CW and CW.|False|you rename property to CW |['property']|[]|['property']|False|False|False|True|False|True
False|44396500|45032910|3|0|Therefore, if the keys used in your serialized data format do n't match the property names from your data type, you can manually implement this enum and set the appropriate CW for the required cases.|True|keys used in your serialized format n't match names from type |['type', 'keys', 'names', 'format']|[]|['type', 'keys', 'names', 'format']|False|False|False|False|False|False
True|29599005|43198481|4|0|Note: if you want CW as a string, it is very simply to convert to a string: CW|True|you want CW as string |['string']|[]|['string']|False|False|False|True|False|True
False|31469441|31470302|6|0|Disadvantage: If you want to fetch single id then you will need to iterate through the array.|True|you want to fetch id then you will need to iterate through array |['array']|[]|['array', 'id']|False|False|False|False|False|False
False|31469441|31509502|0|3|I'm not sure if this applies to some Java frameworks, too.|False|this applies to frameworks |['frameworks']|[]|['frameworks']|False|False|True|True|False|True
True|29775797|49517293|0|0|I think that, we do n't need parse the JSON object into a string, if the remote server accepts json into they request, just run:|True|server accepts json into they request |['json', 'server', 'json']|[]|['JSON', 'server', 'json']|False|False|False|True|False|True
False|42360139|42360418|12|0|Note that there are some guides that will try to solve this by `` undoing'' the defaults, rather than just not implementing it in the first place ... If you factor in that we're now working with Open Source, this is redundant work, bad code and frankly an old habit that will disappear soon.|False|you factor in that we 're now working with Source |['factor']|['factor']|['factor']|False|False|False|False|False|False
False|42360139|42360418|17|0|Forcing a Particular Format If you would like to restrict the response formats for a specific action you can, you can apply the -LSB- Produces -RSB- filter.|True|you would like to restrict formats for action you can |['formats', 'action']|[]|['formats', 'action']|False|False|False|False|False|False
False|42360139|42360418|18|0|The CW filter will force all actions within the CW to return JSON-formatted responses, even if other formatters were configured for the application and the client provided an CW header requesting a different, available format.|True|formatters were configured for application |['application', 'formatters']|[]|['application', 'formatters']|False|False|False|False|False|False
True|36856232|36856787|8|4|With this, you can check if the file exists.|True|file exists |['file']|[]|['file']|False|False|False|True|False|True
False|36856232|36856787|8|8|the callback will contain a stats object which will be null if the file does not exist.|True|file not exist |['file']|[]|['file']|False|False|False|False|False|False
False|36001695|49575969|0|0|Not sure if anyone still runs into this issue but I was able to address this in a dotnetcore console project ( netcoreapp2 .0 ) via:|False|anyone still runs into issue but I was able to address this in project -LRB- .0 -RRB- via : |['project']|[]|['issue', 'anyone', 'project']|False|False|True|True|False|True
True|30568353|46601536|1|0|EDIT: And use a protected/package-protected default constructor for parent classes if you have inheritance.|True|you have inheritance |['inheritance']|[]|['inheritance']|False|False|False|True|False|True
True|30480672|30480777|4|2|Last note: this works only if your value is a String.|True|value is String |['value']|[]|['value']|False|False|False|False|True|True
False|37010891|45854566|6|0|You can use CW persistence annotation with CW, if you want it to be ignored by persistence provider.|True|you want it to be ignored by provider |['provider']|[]|['provider']|False|False|False|False|False|False
False|28802544|54984848|1|1|It can be as simple as LINK if you are using ISO-8601 values ( `` 2019-01-31'' )|False|you are using values `` 2019-01-31 -RRB- |['values']|[]|['values']|False|False|False|False|False|False
False|34944099|34946395|1|1|Depending on your needs you can either look into how to read files in JavaScript ( CW could be an option if you're running in the browser ) or use some other loaders as described in LINK ( assuming you are using NodeJS ).|True|you 're running in browser |['browser']|[]|['browser']|False|False|False|False|False|False
False|28164849|36971694|0|0|While both of the above answers work well if key, value are strings, I had a situation to append a string and integer ( jq errors using the above expressions )|True|key |['key']|[]|['key']|False|False|False|False|False|False
False|28957285|45994247|0|0|There are already few answers here, but I would like to add that if you are using CW to Obfuscate your code & do n't use CW in your model class, then your GSON wo n't work.|True|you are using CW to Obfuscate code & n't use CW in class |['class']|[]|['class', 'code']|False|False|False|False|False|False
False|28957285|45994247|2|0|Of Course you can tell proguard to not obfuscate your model, but if you would like to have model obfuscated, then you must specify CW|True|you would like to have model obfuscated |['model']|[]|['model']|False|False|False|False|False|False
False|28957285|56427152|0|2|No need to add @SerializedName to each and every field explicitly if the field name is similar to the Json key being used for it.|False|name is similar to key being used for it |['name', 'key']|[]|['name', 'key']|False|False|False|False|False|False
True|33650399|42032709|0|0|json-loader does n't load json file if it's array, in this case you need to make sure it has a key, for example|True|it 's array |['array']|[]|['array']|False|False|False|False|True|True
True|32960857|32967407|5|2|This will also prevent values being in the wrong columns if some objects have a different key order.|True|objects have order |['objects', 'order']|[]|['objects', 'order']|False|False|False|True|False|True
True|31096130|31096160|2|0|So if the CW format is what you want, then simply stringify that:|True|format is what you |['format']|[]|['format']|False|False|False|True|False|True
True|30481979|32956160|0|0|Based on the LINK, the easiest way is to use a CW request which according to the docs either `` adds a new list member or updates the member if the email already exists on the list''.|True|email already exists on list |['list', 'email']|[]|['list', 'email']|False|False|False|True|False|True
True|31537153|34516075|0|0|This can happen if you have a newline ( or other control character ) in a JSON string literal.|True|you have newline -LRB- or other character -RRB- in string literal |['string', 'newline', 'character']|[]|['string', 'newline', 'character']|False|False|False|True|False|True
True|31537153|43995658|0|0|I'd recommend you to use a text editor such as Vim to find if there are any ( invisible ) special or escape characters causing this issue.|True|there are any -LRB- invisible -RRB- special or characters causing issue |['characters']|[]|['characters', 'issue']|False|False|False|True|False|True
False|31537153|43995658|1|0|Or if you are using windows, it's even simple ... just copy-paste the code in windows notepad, and it will most likely show any invisible unwanted escape characters or line breaks etc..|True|you are using windows |['windows']|[]|['windows']|False|False|False|False|False|False
True|28646332|28647129|2|1|For example, if the request says it accepts XML, but not JSON, and there is a message converter installed that can transform the list to XML, then XML will be returned.|True|request says it accepts XML |['request']|[]|['request']|False|False|False|True|False|True
False|28646332|38258959|2|1|Spring MVC will setup converters for XML ( using JAXB ) and JSON if Jackson libraries are on he classpath.|True|libraries are on he |['libraries']|[]|['libraries']|False|False|False|False|False|False
False|29758765|41046591|3|0|... but the constructor will be useful if you want to convert the children json object too.|True|you want to convert object too |['object']|[]|['object']|False|False|False|False|False|False
False|37864542|37897833|2|2|Similarly, it needs to be able to serialize the state of global variables between nodes and sub-jobs in the build, which is what I think is happening for you and I and why it only occurs if you add that additional build step.|False|you add that additional build step |['step']|[]|['step']|False|False|False|False|False|False
False|30895286|37819589|0|2|An internal helper class could easily be used instead if you do n't want to add a new dependency.|False|you n't want to add dependency |['dependency']|['dependency']|['dependency']|False|False|False|False|False|False
False|42981409|43056278|1|3|Since CW uses EG ( precision ), CW removes lower digits of fraction parts and destroys original value even if PHP's float could hold more precise float value.|False|'s float could hold precise value |['value', 'float']|[]|['value', 'float']|False|False|False|False|False|False
False|42981409|46390357|1|1|I am adding this as a second solution because I am not sure if the second solution works fine in all cases where the first solution has proven to work.|False|solution works fine in cases where solution has proven to work |['cases', 'solution']|[]|['cases', 'fine', 'solution']|False|False|True|True|False|True
False|38388824|38392716|3|4|However, this limitation comes from Java, not Maven, as ( normally ) in Java a class loader will only provide access to a single class definition even if multiple definitions are found on the classpath.|False|definitions are found on classpath |['classpath', 'definitions']|[]|['classpath', 'definitions']|False|False|False|False|False|False
True|28596295|48112890|1|0|From this if a user need message then he can get alert message.|True|message then |['message']|[]|['message']|False|False|False|False|True|True
True|31276220|32931094|3|0|You can fix this problem if you are the owner of both domains:|False|you are owner of domains |['owner']|[]|['domains', 'owner']|False|False|False|False|True|True
True|29696572|29696688|0|0|you can use push method only if the object is an array:|True|object is array |['array', 'object']|[]|['array', 'object']|False|False|False|False|True|True
True|29696572|41064401|0|0|make sure you push into an Array only and if their is error like Uncaught TypeError: data.push is not a function ** then check for type of data you can do this by consol.log ( data ) hope this will help|True|their is error like TypeError : data.push not function ** then check for type of data you can do this by consol.log -LRB- data -RRB- hope this will help |['function', 'type', 'typeerror']|['error']|['function', 'data', 'data.push', 'consol.log', 'error', 'type', 'TypeError']|False|False|False|False|True|True
False|42179037|42179082|1|0|Note: If CW is a string, then specify the encoding and remember the CW options as well.:|True|CW is string |['string']|[]|['string']|False|False|False|False|False|False
True|43494824|43495014|4|0|It is perfectly okay to store a complete structure as one bit of information if it is one bit of information actually.|False|it is bit of information actually |['bit']|[]|['information', 'bit']|False|False|False|False|True|True
False|43494824|43495014|5|4|Especially if the same person might occur in many different rows it is definitely wrong to use an XML/JSON approach.|False|person might occur in rows |['person', 'rows']|[]|['person', 'rows']|False|False|False|False|False|False
False|43494824|43651382|2|0|Also, most of the json processing if at all the field was queried would be outside the sql environment as sql is just not meant for json processing.|False|at field was queried |['field']|[]|['field']|False|False|False|False|False|False
False|43494824|43674507|11|0|Note that CHECK constraints might slow down your insert/update processes so you might avoid them if you need faster write performance.|False|you need faster write performance |['performance']|['performance']|['performance']|False|False|False|False|False|False
False|43494824|43674507|12|0|Compressed JSON storage If you have large JSON text you can explicitly compress JSON text using built-in COMPRESS function.|False|you have text you can explicitly compress text |['compress', 'text']|[]|['COMPRESS', 'text']|False|False|False|False|False|False
True|40574159|40574235|3|1|This only works if the URL provides JSONP ( which is a different subset of JavaScript ), which this one does n't.|False|URL provides JSONP -LRB- which is subset of JavaScript -RRB- |['javascript', 'subset']|[]|['JavaScript', 'subset']|False|False|False|True|False|True
False|40574159|51019890|0|0|Try to use express.static ( ) if you are using Node.js.|False|you are using Node.js . |['node.js']|[]|['Node.js']|False|False|False|False|False|False
False|40574159|51019890|1|1|For example, if you keep your images, CSS, and JavaScript files in a directory named public, you can do as below −|False|you keep images |['images']|[]|['images']|False|False|False|False|False|False
False|29313687|29330280|1|0|But if you ca n't use a Java class you can use one of these two solutions.|True|you n't use class you can use one of solutions . |['class', 'solutions']|[]|['class', 'solutions']|False|False|False|False|False|False
False|29313687|47345702|0|0|To add on to Andrea's solution, if you are passing an array of JSONs for instance|True|you are passing array of JSONs for instance |['array', 'instance']|[]|['array', 'instance']|False|False|False|False|False|False
False|44655562|50053529|1|0|Some CW structs will be able to parse your CW file just fine if you restructure it using recursive hashes, i.e. if your CW just contains an array of CW which in turn contains ( one or several ) CW.|False|you restructure it using hashes |['hashes']|[]|['hashes']|False|False|False|True|False|True
True|31930041|31935351|4|0|POSTSCRIPT: walk/1 is a built-in in versions of jq > 1.5, and can therefore be omitted if your jq includes it, but there is no harm in including it redundantly in a jq script.|False|jq includes it |['jq']|[]|['jq']|False|False|False|True|False|True
True|31930041|37175540|0|0|In principle, if you have access to bash or some other advanced shell, you could do something like|False|you have access to bash or shell |['access', 'shell']|[]|['access', 'shell']|False|False|False|True|False|True
False|31930041|37175540|1|4|It's probably also worth noting that if you ca n't use bash you can get the same results with temporary files, it's just not as clean.|False|you n't use bash you can get results with files |['results', 'files']|[]|['results', 'files']|False|False|False|False|False|False
True|31930041|37175540|2|6|Alternatively if you want them to be represented as a set, and the elements are strings, you could put them in objects like CW.|False|you want them to be represented as set |['set']|[]|['set']|False|False|False|True|False|True
False|31930041|37175540|3|0|From the comment discussion: If you want to get a better idea of why the the json is n't the same, then|False|you want to get idea of why json n't same |['json']|[]|['idea', 'json']|False|False|False|False|False|False
False|30060006|57323162|1|0|This means, if we want to generate an ObjectMapper in a Spring Boot test, with JUnit 5, we have to:|False|we want to generate ObjectMapper in test |['test', 'objectmapper']|[]|['test', 'ObjectMapper']|False|False|False|False|False|False
False|44343997|52471434|0|1|json is that it can not be published, and it will be ignored if found in any place other than the top level package.|False|found in other than package |['package']|[]|['package']|False|False|False|False|False|False
False|36184641|36188796|0|0|Even if some class does n't expose an CW method, you can still iterate it with CW statement by providing an extension function CW:|False|class n't expose method |['class', 'method']|[]|['class', 'method']|False|False|False|False|False|False
True|34287402|52277406|0|2|For example, if the user does not have access to the data URL and gets some HTML instead.|False|user not have access to URL and gets HTML instead . |['access']|['user']|['access', 'user']|False|False|False|True|False|True
True|31905260|35424786|0|0|This may not qualify for the complete answer, but if the purpose is to send a message attachment, you can send a CWd JSON structure as the value of the CW parameter, like so ( split into multiple lines for clarity ):|False|purpose is to send attachment |['attachment']|[]|['purpose', 'attachment']|False|False|False|True|False|True
False|29965764|29966016|1|0|then if you need you can also create a list in this way:|False|you need you can also create list in way |['list']|[]|['way', 'list']|False|False|False|False|False|False
True|45598461|45603025|2|1|It's easy enough to adapt the code if that's not the case )|False|that not case |['case']|[]|['case']|False|False|False|False|True|True
False|36307487|52992806|0|0|Yep, double curly brackets is the way to go to achieve this - make sure you have the latest version of Postman ( though if you are still running 2014 code when this feature was introduced, shame on you ! )|False|you are still running code when feature was introduced |['feature']|['feature']|['feature', 'code']|False|False|False|False|False|False
False|36177629|36178202|4|0|( Note that you might need to change the method name if you want to keep both the first call and this one ).|False|you want to keep both call and one |['call']|[]|['call']|False|False|False|False|False|False
True|35844138|35845278|1|0|There is a already an LINK for this in the postgres driver Github repository ( even if the problem seems the be the serverside processing ).|False|problem seems the be processing -RRB- |['processing']|[]|['problem', 'processing']|False|False|False|True|False|True
False|41336663|41336822|1|0|EDIT: If your intention is to get the id and other properties from the result object and you want to see it console to know if its there then you can check with CW and access the property if it does exist:|False|intention is to get id and properties from object and you want to see it console to know its there |['properties', 'console', 'object']|[]|['properties', 'console', 'intention', 'object', 'id']|False|False|False|False|False|False
False|41336663|41336869|2|0|Note that if you use Chrome's console you should be able to browse through the object without having to stringify the JSON, which makes it easier to debug.|False|you use 's console you should be able to browse through object without having to stringify JSON |['console', 'object']|[]|['console', 'object']|False|False|False|True|False|True
False|39024354|46159307|0|0|It is worth noting that if you do control the json output like with inline CW option,|False|you do control output like with option |['option', 'output']|[]|['option', 'output']|False|False|False|False|False|False
False|39024354|46159307|3|1|If you have a highly developed modeling, you will more then likely have a set where you think you going to get your intended entity and it's child list, but if those list items also have children, or other parents then you will load those.|False|you have a developed modeling |['modeling']|[]|['modeling']|False|False|False|True|False|True
False|37392733|37393711|1|1|But if there was a two-way linkage between fields, since CW ignores the annotated property, you may avoid the infinite recursion.|False|there was linkage between fields |['linkage', 'fields']|[]|['linkage', 'fields']|False|False|False|False|False|False
False|37392733|37393711|4|0|To recap, if you do n't need those properties in the serialization or deserialization process, you can use CW.|False|you n't need properties in serialization or process |['properties', 'process', 'serialization']|[]|['properties', 'process', 'serialization']|False|False|False|False|False|False
True|34600003|34600032|1|0|For instance, if one of the values is CW, the CW would produce an invalid JSON which can not be loaded:|False|one of values is CW |['values']|[]|['values']|False|False|False|False|True|True
True|30101603|43458007|0|0|"FYI, if someone's using jsonb in > = 9.5 and they only care about top-level elements being merged without duplicate keys, then it's as easy as using the | | operator:"|False|'s jsonb in > = 9.5 and they only care about elements being merged without duplicate keys |['jsonb', 'keys', 'elements']|[]|['jsonb', 'keys', 'elements']|False|False|False|False|True|True
False|29571284|29574160|0|2|For instance, you have to define if parameters in a JSON body are equivalent to querystring parameters or something else entirely.|False|parameters in body are equivalent to querystring parameters or something entirely |['parameters']|[]|['body', 'something', 'parameters']|False|False|False|False|False|False
True|29571284|29574160|3|2|So, if a client has a broken implementation, it can write the CW request as a CW, sending the CW method, and you can have a middleware that's decoupled from your application implementation and rewrites the method accordingly.|False|client has implementation |['client', 'implementation']|[]|['client', 'implementation']|False|False|False|True|False|True
False|29512839|49918845|3|0|Note: If you are adding instances of your custom types ( structs ) into the dictionary make sure your types conform to the CW protocol and if you are adding objects of your custom classes into the dictionary make sure your classes inherit from CW and conform to the CW protocol.|False|you are adding instances of types -LRB- structs -RRB- into dictionary make sure types conform to protocol |['types', 'instances', 'structs', 'dictionary', 'protocol']|[]|['types', 'instances', 'structs', 'dictionary', 'protocol']|False|False|False|False|False|False
False|44839753|44842806|0|1|You can check for Jackson dependency in your CW in the dependency hierarchy tab if using eclipse.|False|using eclipse |['eclipse']|[]|['eclipse']|False|False|False|False|False|False
False|40973633|40973702|0|2|For example, if you had a CW java class ( such as shown below ) that corresponded to your json, then your retrofit api could return CW|False|you had class -LRB- as shown below -RRB- that corresponded to json |['json', 'class']|[]|['json', 'class']|False|False|False|False|False|False
False|31224206|31224444|2|0|But if you are n't thinking about supporting this yet I would simply remove CW from the framework list and your errors will probably go away.|False|you n't thinking about supporting this yet I would simply remove CW from list and errors will probably go away . |['list']|[]|['errors', 'list']|False|False|False|False|False|False
True|33088462|33094930|0|0|Well, if you just need a single extra property, one simple approach is to parse your JSON to a CW, use CW to populate your class from the CW, and then use CW to pull in the extra property.|False|you just need property |['property']|[]|['property']|False|False|False|True|False|True
False|39406043|43759870|1|0|Note that if you would have generated with ng new YourAppname - this assets directory exists same line with ` app' directory, and services should be child directory of app directory.|False|you would have generated with ng YourAppname - directory exists line with directory |['line', 'directory']|[]|['ng', 'line', 'directory', 'YourAppname']|False|False|False|False|False|False
True|39406043|52137543|4|1|This mean that you wo n't need to wait until this file will load - as you will if you choice to work with CW - meaning faster application !|False|you choice to work with CW - meaning faster application |['application', 'choice']|[]|['application', 'choice']|False|False|False|False|True|True
True|49645813|49646254|3|0|and if you want it as an array of pairs:|False|you want it as array of pairs : |['array', 'pairs']|[]|['array', 'pairs']|False|False|False|True|False|True
True|34226370|34227629|1|0|CW produces the key names in sorted order ; if you want them in the original order, use CW.|False|you want them in order |['order']|[]|['order']|False|False|False|True|False|True
False|35734411|48058950|0|0|Strictly speaking if your API is returning an OK code with no content you should return 204 ( no content ) - Angular would also be happy with this and not try to parse anything.|False|API is returning code with content |['content']|[]|['content', 'code']|False|False|False|False|False|False
False|30777419|30778141|0|0|With Retrofit 1.9.0, if you use the Callback asynchronous version of the interface,|False|you use version of interface |['version', 'interface']|['interface']|['version', 'interface']|False|False|False|True|False|True
False|29442977|34144457|0|1|The only thing you have to do is to create a JsonObject out of the request String you get, and from there you can continue as if it were JsonObjectRequest.|False|it were JsonObjectRequest |['jsonobjectrequest']|[]|['JsonObjectRequest']|False|False|False|False|False|False
False|29442977|45167215|1|0|if you have n't made any changes to a previously working code then I suggest checking other parameters such as URL, as the IP address may change if you are using your own Computer as a server !|False|you n't made changes to a working code then I suggest checking parameters as URL |['parameters']|[]|['parameters', 'code', 'changes']|False|False|False|False|False|False
False|49996456|51494250|1|0|But if you need to use older versions:|False|you need to use versions : |['versions']|[]|['versions']|False|False|False|False|False|False
True|49996456|51494250|4|0|But if you have an CW property in your CW:|False|you have property in CW : |['property']|[]|['property']|False|False|False|True|False|True
False|33681978|33684128|2|2|But if your content is already serialized to JSON, Web API has no way of knowing that ; it will happily re-serialize the string, adding extra quotes and backslashes in the process.|False|content is already serialized to JSON |['content']|[]|['content']|False|False|False|False|False|False
False|29003215|29003893|1|0|Edit: If for some reason you really do n't want to make your fields public, you can instead decorate them with the LINK to allow them to be serialized and deserialized:|False|for reason you really n't want to make fields public |['reason', 'fields']|[]|['reason', 'fields']|False|False|False|False|False|False
False|34485420|34485530|4|0|Note that if you're developing a web application, it will be way more efficient to store images separately in binary form, and store paths to those images in your JSON or elsewhere.|False|you 're developing application |['application']|[]|['application']|False|False|False|False|False|False
False|47266862|52106099|1|0|You can do this without the CodingKeys ( if the table attribute names on server side are equal to your struct property names ).|False|names on side are equal to names -RRB- |['names']|[]|['names', 'side']|False|False|False|False|False|False
True|47266862|52106099|3|0|Be careful with nested structs: E.g. if you have a property with a custom struct as type, you need to convert that to a dictionary too.|False|you have property with struct as type |['type', 'struct', 'property']|[]|['type', 'struct', 'property']|False|False|False|True|False|True
False|47266862|52106099|4|0|The Array extension is required if you want to create an array of MyStruct dictionaries.|False|you want to create array of dictionaries |['array', 'array', 'dictionaries']|[]|['array', 'Array', 'dictionaries']|False|False|False|False|False|False
False|37486251|37491171|2|0|I do n't know why CW returns a promise ( if anyone can shed light, I'm interested ).|False|anyone can shed light |['light']|[]|['anyone', 'light']|False|False|True|False|False|False
False|34057851|34057946|1|1|However, if you want to convert a Python structure to a JSON response, use CW:|False|you want to convert structure to response |['structure', 'response']|[]|['structure', 'response']|False|False|False|False|False|False
False|34057851|49403699|4|0|However, if you want to literally do what these examples show and serve JSON data as a download, use CW instead.|False|you want to literally do what examples show and serve data as download |['download']|[]|['examples', 'data', 'download']|False|False|False|False|False|False
False|30698004|30698135|7|0|JSON dumps are efficient and cross-compatible for many reasons but just taking JSON leads to unexpected results if you want to store and load numpy arrays of any type and any dimension.|False|you want to store and load arrays of type and dimension |['type', 'dimension', 'arrays']|[]|['type', 'dimension', 'arrays']|False|False|False|False|False|False
True|35123835|35183644|2|0|Another benefit of this approach would be if a client wants XML instead of JSON, they would get it.|False|client wants XML of JSON |['client']|[]|['client']|False|False|False|True|False|True
False|43827637|43950849|1|0|Besides it'd be best to bind the event to the document not to the elements if you are adding new CW elements via ajax.|False|you are adding elements via ajax |['elements', 'ajax']|[]|['elements', 'ajax']|False|False|False|False|False|False
True|34516332|34516875|1|0|However this will not result in any errors if the server sends you bad objects because of 2 reasons.|False|server sends you objects |['objects', 'server']|[]|['objects', 'server']|False|False|False|True|False|True
True|29247235|29840307|1|2|Later, if no items get merged into it, you simply CW it before CW gets added to the main object.|False|items get merged into it |['items']|[]|['items']|False|False|False|True|False|True
False|34752200|43743897|1|0|But if we put SerializedName like ( `` username'' ) or ( `` password'' ), they will be serialized with that key|False|we put SerializedName like `` username -RRB- or `` password -RRB- |['username', 'password']|[]|['username', 'password', 'SerializedName']|False|False|False|False|False|False
True|32942661|32943372|2|1|Members of Items.java can be changed if JSON has other keys.|False|JSON has keys |['keys']|[]|['keys']|False|False|False|True|False|True
False|51704138|51751913|11|0|As of these releases, if you try and pass a string with an unmatched surrogate pair, Node will replace that character with the unknown unicode character ( U+FFFD ).|False|you try and pass string with pair |['pair', 'string']|[]|['pair', 'string']|False|False|False|True|False|True
True|51704138|51781777|7|1|And you might also want to install CW to efficiently check if a message contains valid UTF-8 as required by the spec.|False|message contains as required by spec |['message', 'spec']|[]|['message', 'spec']|False|False|False|True|False|True
False|51704138|51816363|0|0|It seems your output is having some spaces, If you have any spaces or if you find any special characters please use Unicode to full fill them.|False|you have spaces or you find characters please Unicode to fill them |['characters', 'fill', 'spaces']|[]|['characters', 'fill', 'spaces']|False|False|False|False|False|False
False|32097209|47358999|0|0|To build on the answer from @jbyler, you can strip out the numberLongs using LINK after you get your data - that is if you're using linux.|False|you 're using linux |['linux']|[]|['linux']|False|False|False|False|False|False
False|29797946|29798770|6|0|If the JSON parsing is done sporadically, this might not have a noticeable effect on performance, but if used improperly in usage-heavy function it could lead to dramatic increase in response times.|False|parsing is done sporadically |['parsing']|[]|['parsing']|False|False|False|False|False|False
False|29797946|29798770|7|0|It should be noted that every.single.statement of JavaScript code in Node.js is executed only one-at-a-time, no matter if it's called from the main function or from a callback or from a different module or whatever.|False|it 's called from function or from callback or from module |['callback', 'function', 'module']|[]|['callback', 'function', 'module']|False|False|False|False|False|False
False|38558844|38560184|3|0|Regarding your original question, if you know you have a JSON object at the top level, you can just use:|False|you know you have object at level |['object', 'level']|[]|['object', 'level']|False|False|False|False|False|False
False|31671634|31672314|2|0|But you can also insert any character of your liking, which would be useful if the zero code point is used as some form of delimiter.|False|point is used as form of delimiter |['delimiter', 'point', 'form']|[]|['delimiter', 'point', 'form']|False|False|False|False|False|False
False|36143683|36144575|0|0|CW is needed if you want to load a file using http.|False|you want to load file using http |['http', 'file']|[]|['http', 'file']|False|False|False|False|False|False
False|31730834|31836226|0|0|From my experience with angular translate a few different issues could be happening here which is hard to pin down because your environment plays a factor into this, if you had a github repo I could clone I could be certain.|False|you had repo I could |['repo']|[]|['repo']|False|False|False|False|False|False
False|31730834|31836226|1|1|I have run into issues using the filter translation with partial and external file loading, I would strongly recommend if you are going to be using partial loading then you only use attributes for setting your translations such as|False|you are going to be using loading then you only use attributes for setting translations such as |['translations', 'attributes', 'loading']|[]|['translations', 'attributes', 'loading']|False|False|False|False|False|False
True|31730834|31836226|4|1|However I would recommend that you make the translation slightly different then the json file so you can see if that is the case before adding the force reload.|False|that is case before adding reload |['reload', 'case']|[]|['reload', 'case']|False|False|False|False|True|True
True|32818884|32828120|0|1|It can read some, but not create, especially if you host in IIS.|False|you host in IIS |['host']|[]|['host']|False|False|False|False|True|True
False|32818884|34838334|0|0|I have found if you create the visual studio solution folder on a UNC path this error will occur.|False|you create folder on path |['path', 'folder']|[]|['path', 'folder']|False|False|False|True|False|True
False|28478221|28478348|1|0|Or shorter if you do n't want the key: value syntax for literals:|False|you n't want key : syntax for literals : |['syntax', 'key', 'literals']|[]|['syntax', 'key', 'literals']|False|False|False|False|False|False
True|35709595|38357877|1|3|It is this variability that can be a pain if your application has specific precision requirements.|False|application has requirements |['application', 'requirements']|[]|['application', 'requirements']|False|False|False|True|False|True
True|35709595|38357877|5|0|So if you are wanting to send a precise numeric value to a consumer and you do n't want automatic conversion of the value into the typical internal numeric representation, your best bet is to ship the numeric value out as a string and tell the consumer exactly how that string should be processed if and when numeric operations need to be performed on it.|False|you are wanting to send value to consumer and you n't want conversion of value into representation |['value', 'consumer', 'representation']|[]|['value', 'conversion', 'consumer', 'representation']|False|False|False|True|False|True
True|35709595|38357877|9|3|Simpler for the client to display stuff on screen perhaps, but this can make extracting the numeric value from the string difficult if the client also needs to make computations on the values.|False|client also needs to make computations on values |['values', 'client', 'computations']|[]|['values', 'client', 'computations']|False|False|False|True|False|True
True|40057854|40058055|5|0|The third option CW is important if the root object of the received JSON is not an array and not a dictionary.|False|object of JSON not array and not dictionary |['array', 'object', 'dictionary']|[]|['array', 'object', 'dictionary']|False|False|False|False|True|True
False|38806490|40377740|1|0|So, if you create/upload your own file in Google Storage -- like I'm doing now while trying to test the same API you are using -- the `` equivalence'' is the following:|False|you create/upload file in Storage -- like I 'm doing now while trying to test API you are using -- equivalence '' is following : |['file']|[]|['following', 'file']|False|False|False|True|False|True
False|29042622|29043450|1|0|To answer your question: If you do n't want to use json-simple in you project you should use the JSONObject from org.json, because it's provided by the Android JDK.|False|you n't want to use json-simple in you project you should use JSONObject from org.json |['jsonobject', 'org.json']|[]|['JSONObject', 'org.json']|False|False|False|False|False|False
False|29042622|51939264|2|1|On the other hand, if you know a prebuilt rest service or something similar that supports Android's JSON even better.|False|you know service or something similar that supports 's JSON better |['service']|[]|['service', 'something']|False|False|False|False|False|False
True|42395200|42395516|2|0|You could also try generating a new project with the cli with CW and see if it contains the CW file.|False|it contains file |['file']|[]|['file']|False|False|False|True|False|True
False|30548822|46422110|2|0|and if they do not have any overlapping ( the same item ), it would throw CW and this finally causes 406.|False|they not have overlapping -LRB- item -RRB- |['item']|[]|['item']|False|False|False|False|False|False
False|31527050|31527918|1|0|It is possible to convert integer and float columns back to PHP numbers by setting the MYSQLI_OPT_INT_AND_FLOAT_NATIVE connection option, if using the mysqlnd library.|False|using library |['library']|[]|['library']|False|False|False|False|False|False
False|37708638|40294345|0|1|( If on the contrary such functionality exists, I at least have n't been able to discover it after quite a bit of searching ).|False|on the contrary functionality exists |['functionality']|['functionality']|['functionality']|False|False|False|False|False|False
False|31102784|31234613|1|1|It's best if you separate those two steps.|False|you separate steps |['steps']|[]|['steps']|False|False|False|True|False|True
False|31102784|31347411|2|0|Polling techniques ( including long-polling, where the server keeps sending `` heartbeat'' to the client as if a non-meaningful response is slowly trickling ) can be used as work-around, but there's always some interval of time where connection is no longer open, until the next cycle happens.|False|response is slowly trickling |['response']|[]|['response']|False|False|False|False|False|False
False|31102784|31366071|0|0|Choice 1 ( If you want a reliable system ): A combination of queuing server ( like AMQP or MQTT etc ) and websocket client like LINK will be robust.|False|you want system -RRB- |['system']|[]|['system']|False|False|False|False|False|False
True|31102784|33598613|1|0|You instantiate it with one line if your push message generation script is on the same server.|False|script is on server |['server', 'script']|[]|['server', 'script']|False|False|False|False|True|True
False|38615482|38749477|2|0|and see if you get a valid response stream.|False|you get stream |['stream']|[]|['stream']|False|False|False|True|False|True
False|35481817|35482323|8|1|This must start with CW ( see above ), so if you wrap it with a bracket ( CW ) it can not be a CW ... But if it matches as CW it must be a CW.|False|you wrap it with bracket -LRB- CW -RRB- it not be CW ... But it matches as CW it must be CW |['bracket']|[]|['bracket']|False|False|False|True|False|True
False|35481817|35482504|3|0|The same applies if you put this into an CW statement.|False|you put this into statement |['statement']|[]|['statement']|False|False|False|True|False|True
True|32071318|32138635|7|0|The whole idea is mapReady is a simple catch ... You can add the if statement to the initialize function.|False|statement |['statement']|[]|['statement']|False|False|False|False|True|True
False|29044209|29044240|1|0|The acutal CW is used for convenience when we want to speed up on parsing, so if you are really aware of security use customised CW calls.|False|you are aware of use customised CW calls |['use']|[]|['use']|False|False|False|False|False|False
False|29044209|29179025|6|0|If you want to see what happens if the CORS headers are not set:|False|you want to see what happens headers not set |['headers']|[]|['headers']|False|False|False|False|False|False
True|29044209|29186757|6|0|To be safe, you have to both set the CW option and, if that option is CW, also the CW option.|False|option is CW |['option']|[]|['option']|False|False|False|False|True|True
True|33207376|42820141|0|2|What I do is specifically ask if the object responds to a particular method.|False|object responds to method |['object', 'method']|[]|['object', 'method']|False|False|False|True|False|True
False|42245288|42257772|1|0|On the other hand, if ( as @NicHuang asked ) you want to add the JSON object to the beginning of the array, you could use the pattern:|False|-LRB- as @NicHuang asked -RRB- you want to add object to beginning of array |['array', 'object']|[]|['array', 'object', 'beginning', '@NicHuang']|False|False|False|False|False|False
True|36354704|50128788|0|1|Or while unwrapping you can assign empty string to property if the value is nil|False|value is nil |['value']|[]|['value', 'nil']|False|False|False|False|True|True
True|36354704|50148332|1|0|If you do not use optional values, you have to control parameters while parsing and add a default value if you want a crash free app.|False|you not use values |['values']|[]|['values']|False|False|False|True|False|True
True|36354704|50148332|1|1|And you would n't know if it was nil or empty string from server.|False|it was nil or empty string from server |['server', 'string']|[]|['server', 'string']|False|False|False|False|True|True
False|36354704|50187959|0|0|Yes, you should use optional if the property is not necessary in API and if you want some value in the mandatory property then assign blank value:|False|property not necessary in API and you want value in property then assign value |['value', 'property']|[]|['value', 'property']|False|False|False|False|False|False
False|36354704|50571815|1|0|So keep the required properties as non-optionals and create object only if they are present in the response ( you can use if-let or gaurd-let to check this in response ), else fail the creation of the object.|False|they are present in response -LRB- you can use if-let or gaurd-let to check this in response -RRB- |['response']|[]|['response']|False|False|False|False|False|False
False|30249406|30266100|0|0|I do n't know if it's the best solution, but what I'm trying now is to just pass values as strings unformatted except for a decimal point, like so:|False|it 's solution |['solution']|[]|['solution']|False|False|True|False|True|True
True|30249406|53679769|2|0|However it would only be meaningful if any part of the system avoids floating point too.|False|part of system avoids point too |['point', 'system', 'part']|[]|['point', 'system', 'part']|False|False|False|True|False|True
False|30249406|53679769|2|1|Even if the backend is only passing data and not doing any calculation, using floating point would eventually result in what you see ( in the program ) is not what you get ( on the json ).|False|backend is only passing data and not doing calculation |['calculation', 'backend']|[]|['data', 'calculation', 'backend']|False|False|False|False|False|False
False|38380462|43192024|5|0|Beware: Also, on client side, if you make ajax request and use JSON.parse ( `` OK'' ), it throws Unexpected token ` O'|False|you make request and JSON.parse -LRB- '' -RRB- |['request']|[]|['JSON.parse', 'request']|False|False|False|True|False|True
True|40421100|40423914|3|0|There's no error because CW satisfies type CW because it has all of its properties, and the CW function can be called with no runtime errors even if what it receives is n't an instance of CW as long as it has the same properties.|False|what it receives n't instance of CW long as it has properties |['properties', 'instance']|[]|['properties', 'instance']|False|False|False|False|True|True
True|40421100|40423914|9|0|Then you'll get the error because it's not a string, it's an object, and if you already have it in this form then there's no need to use CW.|False|you already have it in form then there 's need to use CW |['form']|[]|['need', 'form']|False|False|False|True|False|True
False|40421100|40423914|10|0|But, as I wrote, if you're going with this way then you wo n't have an instance of the class, just an object that has the same properties as the class members.|False|you 're going with way then you n't have instance of class |['class', 'instance']|[]|['way', 'class', 'instance']|False|False|False|False|False|False
False|30082277|44479726|3|0|Note that if you want to specify the entire contents of a page, an identifier such as CW is LINK.|False|you want to specify contents of page |['contents', 'page']|[]|['contents', 'page']|False|False|False|False|False|False
False|29858248|29901800|1|0|which would return the value at given path, or, if path is missing, 0 ( default value )|False|path is missing |['path']|[]|['path']|False|False|False|False|False|False
False|30943675|30968249|2|0|Works fine with me ( If I replace `` Banner'' with `` banner'' - got wrong object with null `` banner'' field. )|False|I replace `` Banner '' `` banner '' - got object with null '' field . |['banner', 'banner', 'object', 'field']|[]|['banner', 'Banner', 'object', 'field']|False|False|False|False|False|False
False|30943675|31045976|0|0|I would suggest below ; ( If you are using ObjectMapper )|False|you are using ObjectMapper -RRB- |['objectmapper']|[]|['ObjectMapper']|False|False|False|False|False|False
True|30125965|30186380|12|0|So if PowerShell is your thing, you could have the best of both worlds:|False|PowerShell is thing |['powershell']|[]|['PowerShell', 'thing']|False|False|False|False|True|True
False|30125965|30317694|3|0|This ensures that even if the manifest for the locale does n't contain the translation yet we still populate it with the English US version.|False|the manifest for locale n't contain translation yet we still populate it with version |['version', 'translation', 'locale']|[]|['version', 'translation', 'locale']|False|False|False|False|False|False
False|29347092|29347148|4|0|Also note that although your example contained only CW values, but if the value type is varying ( e.g. CW, numbers etc. ), you may use CW for the value type, in which case your map would be of type CW.|False|type is varying |['type']|[]|['type']|False|False|False|False|False|False
False|36141388|36141631|1|0|( Or just CW if you're using just json. )|False|you 're using json |['json']|[]|['json']|False|False|False|False|False|False
True|36141388|36141631|3|1|So if the data is a nested json structure, the function will not return any of the deeper keys.|False|data is structure |['structure']|[]|['data', 'structure']|False|False|False|False|True|True
False|36141388|57174042|0|0|Here is the example if you want to get the key list of each object:|False|you want to get list of object : |['list', 'object']|[]|['list', 'object']|False|False|False|False|False|False
False|28405545|50467797|0|1|JsonObject is working fine but if you still want to use JSONObject instead of JsonObject then you can use it that way:|False|you still want to use JSONObject of JsonObject then |['jsonobject', 'jsonobject']|[]|['JSONObject', 'JsonObject']|False|False|False|False|False|False
False|28807919|52091341|0|2|It returns true if the list is empty otherwise it gives false.|False|list is otherwise it gives false |['list']|[]|['list']|False|False|False|False|False|False
False|46733354|47864172|2|0|Furthermore, if you are making any request when the component is about to load then simply replace CW with CW and change the render function like so:|False|you are making request when component is about to load then simply |['request', 'component']|[]|['request', 'component']|False|False|False|False|False|False
False|35760096|35760153|1|1|One quick workaround ( if you have the luxury of code generation you can automate this ):|False|you have luxury of generation you can automate this -RRB- |['generation']|[]|['luxury', 'generation']|False|False|False|True|False|True
False|33457654|33457818|1|1|In your controller you are specifying it accepts JSON, but you have not said if the request indicated that the body is in that format.|False|request indicated that body is in format |['format', 'request']|[]|['format', 'body', 'request']|False|False|False|False|False|False
False|33457654|38801498|1|0|For example, if the Content-Type in request Header was one of application/json or application/xml, that means the POST body contains json or XML -LSB- Popular formats -RSB-, and if Jackson library is found in your classpath, Spring will delegate the conversion to MappingJackson2HttpMessageConverter -LSB- for json -RSB- or MappingJackson2XmlHttpMessageConverter -LSB- for xml -RSB-.|False|Content-Type in Header was one of application/json or application/xml |['xml', 'json', 'xml']|[]|['xml', 'json', 'XML']|False|False|False|False|False|False
False|43718733|43719269|1|1|Because Postgres does n't know how to compare two arrays of JSON values, it ca n't decide if your CW produced duplicates.|False|CW produced duplicates |['duplicates']|[]|['duplicates']|False|False|False|False|False|False
False|43718733|43719269|3|0|As pointed out in comments, if you do want to remove duplicates, you can cast the values to something which has a comparison operator defined.|False|you do want to remove duplicates |['duplicates']|[]|['duplicates']|False|False|False|False|False|False
False|45430535|46525856|6|1|( I did not choose this option because the ` lambda' limits are lower than the Firehose limits, you can configure Firehose to write a file each 128Mb or 15 minutes, but if you associate this lambda function to Firehose, the lambda function will be executed every 3 mins or 5 MB, in my case I had the problem of generate a lot of little parquet files, as for each time that the lambda function is launched I generate at least 10 files ).|False|you associate function to Firehose |['function']|[]|['function']|False|False|False|True|False|True
True|48535819|48597168|5|2|I believe if the purpose of creating the json file is to import it in some form, at some stage in future, I think you might have to look at the option of just having a csv file instead, which you use to filter out whatever is required at that point of time.|False|purpose of creating file is to import it in form |['file', 'form']|[]|['purpose', 'file', 'form']|False|False|False|True|False|True
False|48535819|48597168|9|0|Even if you get past this point, you will still run into memory issues, due to the way how you are storing everything in $ json variable which is eating up lot of your memory.|False|you get past point |['point']|[]|['point']|False|False|False|True|False|True
False|48535819|48717328|8|0|Not sure what is the frequency of execution here, but if it is low you can consider your data dumping script to be run through a PHP-CLI instead of HTTP.|False|it is low you can consider data dumping script to be run through PHP-CLI of HTTP . |['script']|[]|['data', 'script']|False|False|True|False|False|False
False|33895076|33899437|2|0|The following example may be of interest to anyone who wants safe CSV ( i.e. even if the values have embedded commas or newline characters ):|False|values have embedded commas or characters |['characters', 'values', 'commas']|[]|['characters', 'values', 'commas']|False|False|False|False|False|False
False|33447334|33447629|4|1|This will work if you do n't specify CW in your declaration of CW.|False|you n't specify CW in declaration of CW |['declaration']|[]|['declaration']|False|False|False|False|False|False
True|30156407|30225282|4|0|After this exit point assuming the data confirmed to the model, you can validate if the data is within certain limits.|False|data is within limits |['limits']|[]|['limits', 'data']|False|False|False|False|True|True
False|30156407|30344043|1|0|In other words, only if you are trying to stream JSON and process it on the fly, you will need to think about second option.|False|you are trying to JSON and process it on fly |['process']|[]|['fly', 'process']|False|False|False|False|False|False
False|30156407|30354106|1|0|If efficiency is your goal and you want to validate every single request, it would be ideal if you could evaluate on the front-end if you are using JavaScript you can use LINK.|False|efficiency is goal and you want to validate request |['goal', 'request']|['efficiency']|['efficiency', 'goal', 'request']|False|False|False|False|False|False
True|30156407|30355169|2|0|However, if your server delivers public api services then you should validate the calls upfront.|False|server delivers services then you should validate upfront . |['services', 'server']|[]|['services', 'server', 'upfront']|False|False|False|True|False|True
True|36745691|36763214|1|0|However, if you just have a local repo without releases, you have to use:|False|you just have repo without releases |['releases', 'repo']|[]|['releases', 'repo']|False|False|False|True|False|True
False|30981565|31913188|0|0|Well to be clear if you are releasing your app to devices with ART you will have a huge speed advantage trough parsing.|False|you are releasing app to devices with ART you will have parsing |['devices', 'parsing']|[]|['devices', 'parsing', 'app']|False|False|False|False|False|False
False|42426549|42453067|1|1|This is no longer the case if you are starting via a local driver provider.|False|you are starting via provider |['provider']|[]|['provider']|False|False|False|False|False|False
False|46991237|46991300|6|0|This solution has one clear adventage over other solutions provided here - it does n't require you to rebuild entire application if your json will change ( it's loaded dynamically from a separate file, so you can modify only that file ).|False|json will change |['json']|[]|['json']|False|False|False|False|False|False
False|34325096|34377323|1|1|So if you hardcode this name you should remember to insert them or you will get error.|False|you hardcode name you should remember to insert them |['name']|[]|['name']|False|False|False|True|False|True
False|34325096|56794946|2|0|This is much better than using the CW because it does n't break if you do a more complex query, where Django uses aliases and where there are field name collisions.|False|you do a complex query |['query']|[]|['query']|False|False|False|True|False|True
False|40995251|49786064|2|1|If you are running test in AWS itself, be sure to check CloudWatch logs as in lambda it wont output full JSON file if its too long.|False|you are running test in AWS itself |['test']|[]|['test']|False|False|False|False|False|False
False|36318849|42605156|0|1|The inheritance model will vary by language during export from swagger specifically, but in practice method definitions specify the acceptable parameter types using the base model if you want to be able to accept multiple subclasses that inherit the same base model.|False|you want to be able to accept subclasses that inherit model |['model', 'subclasses']|[]|['model', 'subclasses']|False|False|False|False|False|False
False|33122014|33168942|2|2|It is easier if you are running a Javascript project.|False|you are running project |['project']|[]|['project']|False|False|False|False|False|False
True|33122014|33174045|0|1|As others have already pointed out, there is not much you can do to avoid conflicts if you have that high number of changes happening to the config all the time.|False|you have number of changes happening to config time |['number', 'config', 'time']|['time']|['number', 'config', 'time', 'changes']|False|False|False|True|False|True
False|33122014|33262179|1|0|This should n't be the case, you only get conflicts if same line is modified by different people, committed and then later merged.|False|line is modified by people |['line']|[]|['people', 'line']|False|False|False|False|False|False
False|33122014|33296381|0|2|In order to find out, you can open a json file with a Hex editor and see if all line endings are consistent across the whole file.|False|endings are consistent across file |['file']|[]|['file', 'endings']|False|False|False|False|False|False
True|31473215|49726900|1|0|Let me know if you have a sample Dataframe and a format of JSON to convert.|False|you have sample Dataframe and format of JSON to convert |['sample', 'format']|[]|['sample', 'format']|False|False|False|True|False|True
True|47232187|47232318|1|1|That means you do n't have to use CW anymore if you are on the latest release.|False|you are on release |['release']|[]|['release']|False|False|False|False|True|True
True|29164419|36127195|1|0|In pre-marshalling method, you have to pass a modified fields CW to CW function if client's email is CW.|False|'s email is CW |['email']|[]|['email']|False|False|False|False|True|True
True|29164419|36127195|3|1|The CW function by default removes all fields those are CW or you have to explicitly pass the field names if that's not desired and you have to pass CW argument too if CW takes the same.|False|that not desired and you have to pass argument too CW takes same |['argument']|[]|['argument']|False|False|False|True|False|True
False|35444968|35519498|13|1|Additionally, it has no package dependencies, parameterizes the column name building logic, and forwards variadic arguments to CW, so for example you can pass CW to inhibit the automatic factorization of character columns normally done by CW, and/or CW to set the row names of the resulting data.frame, or CW to prevent the use of the top-level list component names as row names, if such existed in the input list.|False|such existed in list |['list']|[]|['list']|False|False|False|False|False|False
True|35444968|35544154|2|3|Hence, if there are 4 addresses and 8 plans, there will be 4 * 8 = 32 rows in the joined data frame.|False|there are addresses and plans |['plans', 'addresses']|[]|['plans', 'addresses']|False|False|False|True|False|True
True|35444968|35574705|1|0|If you want to keep the semantics of the fields, like keep all CWs in a single column, you can normalize your data design a bit, and do joins afterwards, if you need the information together:|False|you want to keep semantics of fields |['semantics', 'fields']|[]|['semantics', 'fields']|False|False|False|True|False|True
True|33423853|33579524|4|0|or if you want this without jQuery, which is same as what @daniel - flint recommended.|False|you want this without jQuery |['jquery']|[]|['jQuery']|False|False|False|True|False|True
False|37816269|52402431|0|4|They return CW if no value found.|False|value found |['value']|[]|['value']|False|False|False|False|False|False
True|37816269|52402431|1|0|The first one, CW picks only the first value if there are multiple keys with the same name.|False|there are keys with name |['name', 'keys']|[]|['name', 'keys']|False|False|False|True|False|True
False|37816269|52402431|1|1|If you leave the CW clause, it throws ` Subquery returns more than 1 row' if more keys found ( safe mode ).|False|you leave clause |['clause']|[]|['clause']|False|False|False|False|True|True
False|37816269|52402431|4|1|You can speed up if you prepare a table for the CW subselect.|False|you prepare table for subselect |['table']|[]|['table', 'subselect']|False|False|False|True|False|True
True|37816269|55690616|0|0|Function above not work properly if you have nested JSON in table field.|False|you have JSON in field |['field']|[]|['field']|False|False|False|True|False|True
False|41117918|41148344|2|3|So, if you put JSON into scratch buffer it wo n't get formatted with JSON type formatter.|False|you put JSON into buffer it n't get formatted with formatter . |['formatter', 'buffer']|['buffer']|['formatter', 'buffer']|False|False|False|True|False|True
True|41117918|41148344|3|0|I would encourage you to use scratch files instead of scratch buffers if you want JSON formatting.|False|you want formatting |['formatting']|[]|['formatting']|False|False|False|True|False|True
False|28077854|56348117|3|0|When I cast the array by using $ array = @ ( ) it creates the array as a generic Object -LSB- -RSB-, however, if you explicitly cast the array as a string ( by using -LSB- string -LSB- -RSB- -RSB- $ array = @ ( ) ConvertTo-JSON20 is able to convert the string to JSON.|False|you explicitly cast array as string |['array', 'string']|[]|['array', 'string']|False|False|False|False|False|False
False|27907633|47958749|4|0|And if you wanted to append the data instead of writing a new file just change' mode = `` w''' to' mode = `` a'''.|False|you wanted to append data of writing just ' mode = `` w '' ' to ' mode = `` a '' ' . |['mode']|[]|['data', 'mode']|False|False|False|False|False|False
False|27907633|47958749|6|0|On that note if you change you mind at some point and you want a list out of the reader, Python allows you to put a generator function inside of a list and populate the list automatically.|False|you change you mind at point and you want list out of reader |['point', 'list', 'reader']|[]|['point', 'list', 'reader']|False|False|False|False|False|False
False|27907633|47958749|7|1|Sorry if it was a bit verbose.|False|it was bit verbose . |['bit']|[]|['bit']|False|False|False|False|False|False
False|31822877|53006093|1|0|It's a better solution if you do n't know what timezone is used on a server environment.|False|you n't know what timezone is used on environment |['timezone', 'environment']|[]|['timezone', 'environment']|False|False|True|False|False|False
False|29284266|52163011|0|2|( But even if you did store the data in Base64 string, there is no need concern yourself about encoding/decoding performance because the IO's impact will be more significant. )|False|you did store data in string |['string']|[]|['data', 'string']|False|False|False|False|False|False
False|46559268|47872396|1|0|Angular will only parse the response if the response type is set to `` json'' ( you can see this on line 183 ).|False|type is set `` json '' -LRB- you can see this on 183 -RRB- |['type']|[]|['type']|False|False|False|False|False|False
False|32042938|47358623|1|0|While I agree that if a protocol layer was included in Vert.x it would indeed be first prize, using Gson keeps your server internals pretty organised and is unlikely to be the performance bottleneck.|False|layer was included in Vert.x it would indeed be prize |['layer']|[]|['layer', 'prize']|False|False|False|False|False|False
False|46954692|46955018|2|0|Sets the exit status of jq to 0 if the last output values was neither false nor null, 1 if the last output value was either false or null, or 4 if no valid result was ever produced.|False|values was |['values']|[]|['values']|False|False|False|False|False|False
False|46954692|46955018|4|0|In fact, if you do n't care about distinguishing between the different types of error, then you can just lose the CW switch.|False|you n't care about distinguishing between types of error |['types']|['error']|['types', 'error']|False|False|False|False|False|False
False|45532477|45963989|1|2|( Also there is a lot that can go wrong if you do operations like this with regex ... )|False|you do operations like this with regex ... |['regex', 'operations']|[]|['regex', 'operations']|False|False|False|True|False|True
False|34421779|34469643|2|0|BTW: You are directly calling CW, which is very dangerous, if the product does not contain any elements, your code will break.|False|product not contain elements |['product', 'elements']|[]|['product', 'elements']|False|False|False|False|False|False
True|30030933|30031292|1|0|Or if your CW may include more then one object:|False|CW may include more object : |['object']|[]|['object']|False|False|False|False|True|True
False|38993265|39040460|0|0|XML with LINK ( standard library ) or LINK if you are OK with the markup overhead:|False|you are OK with overhead : |['overhead']|[]|['overhead']|False|False|False|False|False|False
False|36003023|36008538|3|0|In this case I believe you can use the CW to write to an open binary file ; however if you need to do something more complicated with the resulting object, you probably need the above code.|False|you need to do something complicated with object |['object']|[]|['object', 'something']|False|False|False|False|False|False
False|30692185|30744774|2|0|LINK which allows you to get the last modification date of a file, so when it is created, you can rely on this information to see if your cache is outdated like you tried to implement it.|False|cache is outdated like you tried to implement it |['cache']|[]|['cache']|False|False|False|False|False|False
True|30692185|30854521|1|2|You could also be bitten by the provider if they reject requests with parameters they do n't expect.|False|they reject requests with parameters they n't expect |['requests', 'parameters']|[]|['requests', 'parameters']|False|False|False|True|False|True
