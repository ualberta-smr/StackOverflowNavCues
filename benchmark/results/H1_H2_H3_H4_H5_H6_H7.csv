IsInsightFulIf?|QuestionId|AnswerID|ParagraphIndex|SentenceIndex|Sentence|TruePositive?|Condition|Tags In Condition|NFReqs|Nouns|IsInterrogative?|IsFirstPerson?|IsUnsurePhrase?|HasWantedGrammerDep?
True|46344963|55428632|1|0|In this case, if one of the element in CW is nil, the whole object is nil while decoding.|False|one of element in CW is nil |['element']|[]|['element', 'nil']|False|False|False|True
True|28459418|53319895|3|0|Idempotent methods are distinguished because the request can be repeated automatically if a communication failure occurs before the client is able to read the server's response.|True|failure occurs before client is able to read 's response |['response', 'client']|['failure']|['response', 'failure', 'client']|False|False|False|True
True|28459418|53319895|3|1|For example, if a client sends a PUT request and the underlying connection is closed before any response is received, then the client can establish a new connection and retry the idempotent request.|True|client sends request and connection is closed before response is received |['response', 'request', 'connection', 'client']|[]|['response', 'request', 'connection', 'client']|False|False|False|True
True|28459418|53319895|7|0|If instead the client uses a PUT request to correct the email, sending to the server all properties of user 1 along with the email, his intended effect will be achieved even if the request has to be re-sent later and user 1 has been modified in the meanwhile -- since the second PUT request will overwrite all changes since the first request.|True|instead client uses request to correct email |['email', 'request', 'client']|[]|['email', 'request', 'client']|False|False|False|True
True|39423367|39423764|9|0|The only ( rare ) option which is useful in Swift is CW which is required if if the JSON root object could be a value type ( CW, CW, CW or CW ) rather than one of the collection types ( CW or CW ).|True|object could be type |['object', 'type']|[]|['object', 'type']|False|False|False|True
True|39423367|39423764|20|0|If you need an item at specific index check also if the index exists|True|you need item at check also index exists |['index', 'check', 'item']|[]|['index', 'check', 'item']|False|False|False|True
True|29599005|43198481|4|0|Note: if you want CW as a string, it is very simply to convert to a string: CW|True|you want CW as string |['string']|[]|['string']|False|False|False|True
True|33660866|49576873|7|1|Virtual generated columns perform much faster, however, if we know our data structure beforehand, we do n't need JSON, we can use traditional columns instead.|True|we know structure beforehand |['structure']|[]|['structure']|False|False|False|True
True|29775797|49517293|0|0|I think that, we do n't need parse the JSON object into a string, if the remote server accepts json into they request, just run:|True|server accepts json into they request |['server', 'json', 'json']|[]|['server', 'json', 'JSON']|False|False|False|True
True|30568353|46601536|1|0|EDIT: And use a protected/package-protected default constructor for parent classes if you have inheritance.|True|you have inheritance |['inheritance']|[]|['inheritance']|False|False|False|True
True|30480672|30480777|4|2|Last note: this works only if your value is a String.|True|value is String |['value']|[]|['value']|False|False|False|True
True|36856232|36856787|8|4|With this, you can check if the file exists.|True|file exists |['file']|[]|['file']|False|False|False|True
True|33650399|42032709|0|0|json-loader does n't load json file if it's array, in this case you need to make sure it has a key, for example|True|it 's array |['array']|[]|['array']|False|False|False|True
True|32960857|32967407|5|2|This will also prevent values being in the wrong columns if some objects have a different key order.|True|objects have order |['objects', 'order']|[]|['objects', 'order']|False|False|False|True
True|31096130|31096160|2|0|So if the CW format is what you want, then simply stringify that:|True|format is what you |['format']|[]|['format']|False|False|False|True
True|30481979|32956160|0|0|Based on the LINK, the easiest way is to use a CW request which according to the docs either `` adds a new list member or updates the member if the email already exists on the list''.|True|email already exists on list |['email', 'list']|[]|['email', 'list']|False|False|False|True
True|31537153|34516075|0|0|This can happen if you have a newline ( or other control character ) in a JSON string literal.|True|you have newline -LRB- or other character -RRB- in string literal |['string', 'character', 'newline']|[]|['string', 'character', 'newline']|False|False|False|True
True|31537153|43995658|0|0|I'd recommend you to use a text editor such as Vim to find if there are any ( invisible ) special or escape characters causing this issue.|True|there are any -LRB- invisible -RRB- special or characters causing issue |['characters']|[]|['issue', 'characters']|False|False|False|True
True|28646332|28647129|2|1|For example, if the request says it accepts XML, but not JSON, and there is a message converter installed that can transform the list to XML, then XML will be returned.|True|request says it accepts XML |['request']|[]|['request']|False|False|False|True
True|28596295|48112890|1|0|From this if a user need message then he can get alert message.|True|message then |['message']|[]|['message']|False|False|False|True
True|31276220|32931094|3|0|You can fix this problem if you are the owner of both domains:|False|you are owner of domains |['owner']|[]|['domains', 'owner']|False|False|False|True
True|29696572|29696688|0|0|you can use push method only if the object is an array:|True|object is array |['object', 'array']|[]|['object', 'array']|False|False|False|True
True|29696572|41064401|0|0|make sure you push into an Array only and if their is error like Uncaught TypeError: data.push is not a function ** then check for type of data you can do this by consol.log ( data ) hope this will help|True|their is error like TypeError : data.push not function ** then check for type of data you can do this by consol.log -LRB- data -RRB- hope this will help |['type', 'function']|['error']|['consol.log', 'data', 'type', 'error', 'function', 'data.push']|False|False|False|True
True|43494824|43495014|4|0|It is perfectly okay to store a complete structure as one bit of information if it is one bit of information actually.|False|it is bit of information actually |['bit']|[]|['bit', 'information']|False|False|False|True
True|40574159|40574235|3|1|This only works if the URL provides JSONP ( which is a different subset of JavaScript ), which this one does n't.|False|URL provides JSONP -LRB- which is subset of JavaScript -RRB- |['subset', 'javascript']|[]|['subset', 'JavaScript']|False|False|False|True
True|31930041|31935351|4|0|POSTSCRIPT: walk/1 is a built-in in versions of jq > 1.5, and can therefore be omitted if your jq includes it, but there is no harm in including it redundantly in a jq script.|False|jq includes it |['jq']|[]|['jq']|False|False|False|True
True|31930041|37175540|0|0|In principle, if you have access to bash or some other advanced shell, you could do something like|False|you have access to bash or shell |['shell', 'access']|[]|['shell', 'access']|False|False|False|True
True|31930041|37175540|2|6|Alternatively if you want them to be represented as a set, and the elements are strings, you could put them in objects like CW.|False|you want them to be represented as set |['set']|[]|['set']|False|False|False|True
True|34287402|52277406|0|2|For example, if the user does not have access to the data URL and gets some HTML instead.|False|user not have access to URL and gets HTML instead . |['access']|['user']|['access', 'user']|False|False|False|True
True|31905260|35424786|0|0|This may not qualify for the complete answer, but if the purpose is to send a message attachment, you can send a CWd JSON structure as the value of the CW parameter, like so ( split into multiple lines for clarity ):|False|purpose is to send attachment |['attachment']|[]|['attachment', 'purpose']|False|False|False|True
True|45598461|45603025|2|1|It's easy enough to adapt the code if that's not the case )|False|that not case |['case']|[]|['case']|False|False|False|True
True|35844138|35845278|1|0|There is a already an LINK for this in the postgres driver Github repository ( even if the problem seems the be the serverside processing ).|False|problem seems the be processing -RRB- |['processing']|[]|['problem', 'processing']|False|False|False|True
True|34600003|34600032|1|0|For instance, if one of the values is CW, the CW would produce an invalid JSON which can not be loaded:|False|one of values is CW |['values']|[]|['values']|False|False|False|True
True|30101603|43458007|0|0|"FYI, if someone's using jsonb in > = 9.5 and they only care about top-level elements being merged without duplicate keys, then it's as easy as using the | | operator:"|False|'s jsonb in > = 9.5 and they only care about elements being merged without duplicate keys |['jsonb', 'elements', 'keys']|[]|['jsonb', 'elements', 'keys']|False|False|False|True
True|29571284|29574160|3|2|So, if a client has a broken implementation, it can write the CW request as a CW, sending the CW method, and you can have a middleware that's decoupled from your application implementation and rewrites the method accordingly.|False|client has implementation |['implementation', 'client']|[]|['implementation', 'client']|False|False|False|True
True|33088462|33094930|0|0|Well, if you just need a single extra property, one simple approach is to parse your JSON to a CW, use CW to populate your class from the CW, and then use CW to pull in the extra property.|False|you just need property |['property']|[]|['property']|False|False|False|True
True|39406043|52137543|4|1|This mean that you wo n't need to wait until this file will load - as you will if you choice to work with CW - meaning faster application !|False|you choice to work with CW - meaning faster application |['application', 'choice']|[]|['application', 'choice']|False|False|False|True
True|49645813|49646254|3|0|and if you want it as an array of pairs:|False|you want it as array of pairs : |['pairs', 'array']|[]|['pairs', 'array']|False|False|False|True
True|34226370|34227629|1|0|CW produces the key names in sorted order ; if you want them in the original order, use CW.|False|you want them in order |['order']|[]|['order']|False|False|False|True
True|49996456|51494250|4|0|But if you have an CW property in your CW:|False|you have property in CW : |['property']|[]|['property']|False|False|False|True
True|47266862|52106099|3|0|Be careful with nested structs: E.g. if you have a property with a custom struct as type, you need to convert that to a dictionary too.|False|you have property with struct as type |['type', 'struct', 'property']|[]|['type', 'struct', 'property']|False|False|False|True
True|35123835|35183644|2|0|Another benefit of this approach would be if a client wants XML instead of JSON, they would get it.|False|client wants XML of JSON |['client']|[]|['client']|False|False|False|True
True|34516332|34516875|1|0|However this will not result in any errors if the server sends you bad objects because of 2 reasons.|False|server sends you objects |['server', 'objects']|[]|['server', 'objects']|False|False|False|True
True|29247235|29840307|1|2|Later, if no items get merged into it, you simply CW it before CW gets added to the main object.|False|items get merged into it |['items']|[]|['items']|False|False|False|True
True|32942661|32943372|2|1|Members of Items.java can be changed if JSON has other keys.|False|JSON has keys |['keys']|[]|['Items.java', 'keys']|False|False|False|True
True|51704138|51781777|7|1|And you might also want to install CW to efficiently check if a message contains valid UTF-8 as required by the spec.|False|message contains as required by spec |['message', 'spec']|[]|['message', 'spec']|False|False|False|True
True|31730834|31836226|4|1|However I would recommend that you make the translation slightly different then the json file so you can see if that is the case before adding the force reload.|False|that is case before adding reload |['reload', 'case']|[]|['reload', 'case']|False|False|False|True
True|32818884|32828120|0|1|It can read some, but not create, especially if you host in IIS.|False|you host in IIS |['host']|[]|['host']|False|False|False|True
True|35709595|38357877|1|3|It is this variability that can be a pain if your application has specific precision requirements.|False|application has requirements |['requirements', 'application']|[]|['requirements', 'application']|False|False|False|True
True|35709595|38357877|5|0|So if you are wanting to send a precise numeric value to a consumer and you do n't want automatic conversion of the value into the typical internal numeric representation, your best bet is to ship the numeric value out as a string and tell the consumer exactly how that string should be processed if and when numeric operations need to be performed on it.|False|you are wanting to send value to consumer and you n't want conversion of value into representation |['consumer', 'representation', 'value']|[]|['consumer', 'representation', 'conversion', 'value']|False|False|False|True
True|35709595|38357877|9|3|Simpler for the client to display stuff on screen perhaps, but this can make extracting the numeric value from the string difficult if the client also needs to make computations on the values.|False|client also needs to make computations on values |['values', 'computations', 'client']|[]|['values', 'computations', 'client']|False|False|False|True
True|40057854|40058055|5|0|The third option CW is important if the root object of the received JSON is not an array and not a dictionary.|False|object of JSON not array and not dictionary |['dictionary', 'object', 'array']|[]|['dictionary', 'object', 'array']|False|False|False|True
True|42395200|42395516|2|0|You could also try generating a new project with the cli with CW and see if it contains the CW file.|False|it contains file |['file']|[]|['file']|False|False|False|True
True|31102784|33598613|1|0|You instantiate it with one line if your push message generation script is on the same server.|False|script is on server |['server', 'script']|[]|['server', 'script']|False|False|False|True
True|32071318|32138635|7|0|The whole idea is mapReady is a simple catch ... You can add the if statement to the initialize function.|False|statement |['statement']|[]|['statement', 'mapReady']|False|False|False|True
True|29044209|29186757|6|0|To be safe, you have to both set the CW option and, if that option is CW, also the CW option.|False|option is CW |['option']|[]|['option']|False|False|False|True
True|36354704|50128788|0|1|Or while unwrapping you can assign empty string to property if the value is nil|False|value is nil |['value']|[]|['nil', 'value']|False|False|False|True
True|36354704|50148332|1|0|If you do not use optional values, you have to control parameters while parsing and add a default value if you want a crash free app.|False|you not use values |['values']|[]|['values']|False|False|False|True
True|36354704|50148332|1|1|And you would n't know if it was nil or empty string from server.|False|it was nil or empty string from server |['server', 'string']|[]|['server', 'string']|False|False|False|True
True|30249406|53679769|2|0|However it would only be meaningful if any part of the system avoids floating point too.|False|part of system avoids point too |['system', 'point', 'part']|[]|['system', 'point', 'part']|False|False|False|True
True|33207376|42820141|0|2|What I do is specifically ask if the object responds to a particular method.|False|object responds to method |['object', 'method']|[]|['object', 'method']|False|False|False|True
True|40421100|40423914|3|0|There's no error because CW satisfies type CW because it has all of its properties, and the CW function can be called with no runtime errors even if what it receives is n't an instance of CW as long as it has the same properties.|False|what it receives n't instance of CW long as it has properties |['instance', 'properties']|[]|['instance', 'properties']|False|False|False|True
True|40421100|40423914|9|0|Then you'll get the error because it's not a string, it's an object, and if you already have it in this form then there's no need to use CW.|False|you already have it in form then there 's need to use CW |['form']|[]|['need', 'form']|False|False|False|True
True|30125965|30186380|12|0|So if PowerShell is your thing, you could have the best of both worlds:|False|PowerShell is thing |['powershell']|[]|['thing', 'PowerShell']|False|False|False|True
True|36141388|36141631|3|1|So if the data is a nested json structure, the function will not return any of the deeper keys.|False|data is structure |['structure']|[]|['structure', 'data']|False|False|False|True
True|48535819|48597168|5|2|I believe if the purpose of creating the json file is to import it in some form, at some stage in future, I think you might have to look at the option of just having a csv file instead, which you use to filter out whatever is required at that point of time.|False|purpose of creating file is to import it in form |['form', 'file']|[]|['form', 'purpose', 'file']|False|False|False|True
True|30156407|30225282|4|0|After this exit point assuming the data confirmed to the model, you can validate if the data is within certain limits.|False|data is within limits |['limits']|[]|['limits', 'data']|False|False|False|True
True|30156407|30355169|2|0|However, if your server delivers public api services then you should validate the calls upfront.|False|server delivers services then you should validate upfront . |['server', 'services']|[]|['server', 'upfront', 'services']|False|False|False|True
True|36745691|36763214|1|0|However, if you just have a local repo without releases, you have to use:|False|you just have repo without releases |['releases', 'repo']|[]|['releases', 'repo']|False|False|False|True
True|33122014|33174045|0|1|As others have already pointed out, there is not much you can do to avoid conflicts if you have that high number of changes happening to the config all the time.|False|you have number of changes happening to config time |['config', 'time', 'number']|['time']|['config', 'changes', 'time', 'number']|False|False|False|True
True|31473215|49726900|1|0|Let me know if you have a sample Dataframe and a format of JSON to convert.|False|you have sample Dataframe and format of JSON to convert |['format', 'sample']|[]|['format', 'sample']|False|False|False|True
True|47232187|47232318|1|1|That means you do n't have to use CW anymore if you are on the latest release.|False|you are on release |['release']|[]|['release']|False|False|False|True
True|29164419|36127195|1|0|In pre-marshalling method, you have to pass a modified fields CW to CW function if client's email is CW.|False|'s email is CW |['email']|[]|['email']|False|False|False|True
True|29164419|36127195|3|1|The CW function by default removes all fields those are CW or you have to explicitly pass the field names if that's not desired and you have to pass CW argument too if CW takes the same.|False|that not desired and you have to pass argument too CW takes same |['argument']|[]|['argument']|False|False|False|True
True|35444968|35544154|2|3|Hence, if there are 4 addresses and 8 plans, there will be 4 * 8 = 32 rows in the joined data frame.|False|there are addresses and plans |['plans', 'addresses']|[]|['plans', 'addresses']|False|False|False|True
True|35444968|35574705|1|0|If you want to keep the semantics of the fields, like keep all CWs in a single column, you can normalize your data design a bit, and do joins afterwards, if you need the information together:|False|you want to keep semantics of fields |['fields', 'semantics']|[]|['fields', 'semantics']|False|False|False|True
True|41117918|41148344|3|0|I would encourage you to use scratch files instead of scratch buffers if you want JSON formatting.|False|you want formatting |['formatting']|[]|['formatting']|False|False|False|True
True|37816269|52402431|1|0|The first one, CW picks only the first value if there are multiple keys with the same name.|False|there are keys with name |['name', 'keys']|[]|['name', 'keys']|False|False|False|True
True|37816269|52402431|5|0|Yep, and if you have the chance, try to upgrade to MySQL 5.7, the built-in functions work much more efficiently.|False|you have chance |['mysql']|[]|['chance', 'MySQL']|False|False|False|True
True|37816269|55690616|0|0|Function above not work properly if you have nested JSON in table field.|False|you have JSON in field |['field']|[]|['field']|False|False|False|True
True|30030933|30031292|1|0|Or if your CW may include more then one object:|False|CW may include more object : |['object']|[]|['object']|False|False|False|True
True|30692185|30854521|1|2|You could also be bitten by the provider if they reject requests with parameters they do n't expect.|False|they reject requests with parameters they n't expect |['requests', 'parameters']|[]|['requests', 'parameters']|False|False|False|True
