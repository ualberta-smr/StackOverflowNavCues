you use `` w + '' for open the file . 

w + open a file for both write and read . overwrite the exist file if the file exist . if the file do not exist , create a new file for reading and writing . 

so instead of CW use CW . 

look to I you can really use thread library or multiprocess to do this in more elegant way by use Locks , instead of run multiple instance of the same python script . 

source : link , link 

but the open function seem to kind of clear the file 

yes , open a file in CW write mode always clear the file ; from the link : 

cw open for write , truncating the file first 

-lsb- ... -rsb- the default mode be CW -lrb- open for read text , synonym of cw -rrb- . for binary read-write access , the mode cw open and truncate the file to 0 byte . cw open the file without truncation . 

you want to lock the file before truncating it . you can also open the file in CW mode -lrb- reading and writing -rrb- , at which point you need to manually truncate it after lock . 

you also will need to lock the file for reading , because you do not want you reader to end up with truncate datum when they try to read while another process be busy replace the contents . use a shared lock , at which point other process be allow to obtain a shared lock too , make it possible for many process to read the datum without have to wait for one another . a process that want to write have to grab a exclusive lock , which be only go to be award when there be no shared lock anymore . 

personally , I would create a context manager that handle the lock -lrb- either in exclusive mode for write , or in shared mode for reading -rrb- , and only truncate the file after obtain the lock . you will also need to account for the file not yet exist , and if you do not want to wait for lock forever , you need to handle timeout -lrb- meaning you need to use CW in a loop and test for the return value to see if the lock be acquire , until a certain amount of time have pass -rrb- . 

in the follow context manager , I use the CW low-level system call to ensure the file be create when try to lock it for exclusive access without truncating it if it already exist : 

the process that try to read the file then use : 

and the process that want to write use : 

if you want to allow for a timeout , add a cw block around the CW block and catch the CW exception ; you will need to decide what should happen then : 

