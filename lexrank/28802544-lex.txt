lexrank.summarize("I be never able to get this to work simple use annotation. to get it to work, I create a link for CW, then I add the CW, along with one more caveat, which be the need to set write-date-as-timestamp to false. see more at LINK. here be a example of what I use. dependency. note: one problem I face with this be that the CW version pull in by another dependency, use version 2.3.2, which cancel out the 2.4 require by the CW. what happen be I get a NoClassDefFound for CW, which be a 2.4 class. so I just need to line up the include dependency version. ContextResolver. Resource class. test. CW result: cw. CW result: cw. see also link for jaxb solution. the CW be deprecate as of version 2.7 of Jackson. instead, you should register the module CW. it be still the same dependency. work fine for I. @jsonserialize and @jsondeserialize work fine for I. they eliminate the need to import the additional jsr310 module:. Deserializer:. Serializer:. in spring boot web app, with ` jackson ' and ` jsr310 ' version `` 2.8.5 ''. the ' @jsonformat ' work:. just a update of Christopher answer. since the version 2.6.0. use the JavaTimeModule instead of jsr310module -lrb- deprecate -rrb-. accord to the link, the new JavaTimeModule use same standard setting to default to serialization that do NOT use Timezone Ids, and instead only use iso-8601 compliant Timezone offset. behavior may be change use SerializationFeature.WRITE _ dates_with_zone_id. import:. code:. and now I can just use CW to read and write my object without any special setup. the simplest solution -lrb- which support deserialization and serialization as well -rrb- be. while use the follow dependency in you project. maven. gradle. no additional implementation of a ContextResolver, Serializer or Deserializer be require.", 1, function (err, toplines, text) { console.log(toplines); });

[ { weight: 0.19202490445663392,
    text: 'the \' @jsonformat \' work:.',
    index: 23 } ]